{"meta":{"title":"extends","subtitle":"","description":"个人博客","author":"extends","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-03-02T02:02:20.971Z","updated":"2022-11-17T07:26:24.000Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2023-03-02T02:02:20.974Z","updated":"2022-11-17T07:26:32.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-03-02T02:02:20.977Z","updated":"2022-11-17T07:27:22.000Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-03-02T02:02:20.978Z","updated":"2022-11-17T07:26:47.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"jenkins配置教程","slug":"jenkins配置教程","date":"2023-04-10T08:56:24.000Z","updated":"2023-04-10T09:00:11.297Z","comments":true,"path":"2023/04/10/jenkins配置教程/","link":"","permalink":"http://example.com/2023/04/10/jenkins%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/","excerpt":"","text":"说明简介 Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 部署环境 jdk环境，Jenkins是java语言开发的，因需要jdk环境。 git&#x2F;svn客户端，因一般代码是放在git&#x2F;svn服务器上的，我们需要拉取代码。 maven客户端，因一般java程序是由maven工程，需要maven打包，当然也有其他打包方式，如：gradle jdk 解压 1$ tar -zxvf jdk-11.0.18_linux-x64_bin.tar.gz 配置环境变量 在文件/etc/profile文件中添加下面的内容 123export JAVA_HOME=/java/jdk8export CLASSPATH=.:$JAVA_HOME/lib/dt.:jar$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin git使用命令安装git 12apt install gityum install git ubuntu系统直接使用apt，其他可以使用yum maven 解压 1$ tar -zxvf apache-maven-3.8.8-bin.tar.gz 配置settings.xml文件 123456789# 添加阿里云镜像&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; Jenkins安装通过docker安装使用的jenkins镜像为jenkins/jenkins:lts，本人安装其他jenkins镜像都会有插件下载不下来的问题。 1$ docker pull jenkins/jenkins:lts 使用命令运行docker容器 12345678docker run -d --name jenkins -p 8080:8080 -p 50000:50000 -v /home/extendy/jenkins-data:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock jenkins/jenkins:lts 等待Jenkins启动后访问8080，会进行项目的基础配置 通过war安装 下载Jenkins.war包 启动Jenkins 直接运行Jenkin的War包： 1nohup java -jar jenkins.war &amp; #后台运行 访问Jenkins 默认端口号为8080，在浏览器输入ip地址+8080端口即可 &#x3D;&#x3D;特别注意：通过war包的方式安装Jenkins，Jenkins的workspace文件夹和其他文件都是在下面的目录下&#x3D;&#x3D; 1/root/.jenkins/ 通过命令进行安装通过命令进行安装会因为SSL证书的问题导致无法安装插件的问题，不推荐 配置解锁jenkins密码进入容器 1$ docker exec -u 0 -it jenkins /bin/bash 查看密码 1$ cat /var/jenkins_home/secrets/initialAdminPassword 解锁后安装推荐的插件之后就可以使用了 部署Maven项目使用gitee项目 下载Gitee和Maven插件登陆Jenkins系统管理 &#x3D;&gt;插件管理 下载Maven Integration plugin和Gitee plugin 全局工具配置系统管理&#x3D;&gt;全局工具配置 配置maven、JDK、git 对应系统安装的路径即可 系统配置系统管理&#x3D;&gt;系统配置&#x3D;&gt;Gitee配置 填入自己在gitee中的仓库地址、gitee的域名和令牌 首次需要点击添加添加一个令牌 令牌使用的是gitee令牌，需要在gitee中生成后复制过来。 项目配置 Gitee链接 选择系统配置中填写的选项 JDK 选择配置好的JDK 源码管理 配置源码仓库地址和选择分支（默认为master分支） 构建触发器 构建环境 前置步骤（Pre Steps） Build 使用Maven来构建项目,命令如下： 1clean install -Dmaven.test.skip=true Post Steps 选择仅在生成成功时运行 添加 执行shell 12345cd /usr/local/javaProject/ # 进入存放项目的文件夹（自定义的）sh stop.sh # 停止正在运行的旧版本项目 shell脚本sh replace.sh # 替换编译后的jar包 shell脚本#启动新编译打包的项目BUILD_ID=dontKillMe nohup java -jar /usr/local/javaProject/springboot_swagger_dome-0.0.1-SNAPSHOT.jar &amp; stop.sh 和 replace.sh 内容： 12345678#stop.sh#找到正在运行旧项目的 编号#然后停止pid=`ps -ef | grep springboot_swagger_dome-0.0.1-SNAPSHOT.jar | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`if [ -n &quot;$pid&quot; ]then kill -9 $pidfi 12345678910#replate.sh#判断指定路径下的jar包是否存在#如果存在，更名备份#将Jenkins打包编译后的项目移动到指定的项目目录下file=&quot;/usr/local/javaProject/springboot_swagger_dome-0.0.1-SNAPSHOT.jar&quot;if [ -f &quot;$file&quot; ]then mv /usr/local/javaProject/springboot_swagger_dome-0.0.1-SNAPSHOT.jar /usr/local/javaProject/springboot_swagger_dome-0.0.1-SNAPSHOT.jar.`date +%Y%m%d%H%M%S`fi mv /root/.jenkins/workspace/test_autodelpment/target/springboot_swagger_dome-0.0.1-SNAPSHOT.jar /usr/local/javaProject/ 测试配置完成后点击立即构建即可执行，可以点击构建历史中的记录&#x3D;&gt;控制台输出，中查看构建控制台输出。","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"author":["extends"]},{"title":"ubuntu更换apt源","slug":"ubuntu更换apt源","date":"2023-04-08T08:47:23.000Z","updated":"2023-04-08T09:05:07.325Z","comments":true,"path":"2023/04/08/ubuntu更换apt源/","link":"","permalink":"http://example.com/2023/04/08/ubuntu%E6%9B%B4%E6%8D%A2apt%E6%BA%90/","excerpt":"","text":"Ubuntu更换apt国内源修改/etc/apt/sources.list配置文件 使用vim编辑器在文件最前面添加内容 vim命令 1$ sudo vim /etc/apt/sources.list 添加内容（阿里源） 12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 保存并退出（vim：w保存；q退出） 更新缓存 12$ sudo apt-get update$ sudo apt-get upgrade 其他数据源清华源 12345678910deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 中科大 12345678910deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 163源 12345678910deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"author":["extends"]},{"title":"MySQL中group的用法","slug":"MySQL中group的用法","date":"2023-04-03T10:46:09.000Z","updated":"2023-04-03T10:46:54.845Z","comments":true,"path":"2023/04/03/MySQL中group的用法/","link":"","permalink":"http://example.com/2023/04/03/MySQL%E4%B8%ADgroup%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"说明：group 一般和聚合函数一起使用，后面可以跟上 HAVING 关键字一起使用。(having 和 where 用法相同，不同的是having可以后跟聚合函数) 关键字 用法 缺点 WHERE 先筛选数据再关联，执行效率高 不能使用分组中的计算函数进行筛选 HAVING 可以使用分组中的计算函数 在最后的结果集中进行筛选，执行效率较低 聚合函数 count() 求行数 sum() 求某列行的值 avg() 求某列的平均值 max() 求某列最大值 min() 求某列最小值 示例有如下表 id name money 1 张三 200 2 张三 100 3 李四 50 4 李四 600 5 王五 400 6 张三 600 使用SQL语句分组查询 12345SELECT `name`, SUM(money)FROM `test`GROUP BY `name` 说明：根据姓名分组统计每个的金钱总数 结果 123张三 900.00李四 650.00王五 400.00","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}],"author":["extends"]},{"title":"maven打包命令","slug":"maven打包命令","date":"2023-04-01T01:18:23.000Z","updated":"2023-04-01T01:19:31.537Z","comments":true,"path":"2023/04/01/maven打包命令/","link":"","permalink":"http://example.com/2023/04/01/maven%E6%89%93%E5%8C%85%E5%91%BD%E4%BB%A4/","excerpt":"","text":"一、常用命令 命令 描述 mvn clean 对项目进行清理，删除target目录下编译的内容 mvn compile 编译项目源代码 mvn test 对项目进行运行测试 mvn package 打包文件并存放到项目的target目录下，打包好的文件通常都是编译后的class文件 mvn install 在本地仓库生成仓库的安装包，可供其他项目引用，同时打包后的文件放到项目的target目录下 二、跳过单元测试跳过单元测试同时也跳过测试代码的编译 1mvn package -Dmaven.test.skip=true 跳过单元测试，不跳过测试代码的编译 1mvn package -DskipTests 三、命令组合使用1mvn clean install package -Dmaven.test.skip=true 依次执行clean、install、package，并跳过测试代码的编译和运行。","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"}],"author":["extends"]},{"title":"Java中Duration类和Period类的使用方法","slug":"Java中Duration类和Period类的使用方法","date":"2023-03-30T09:08:10.000Z","updated":"2023-03-30T09:09:14.871Z","comments":true,"path":"2023/03/30/Java中Duration类和Period类的使用方法/","link":"","permalink":"http://example.com/2023/03/30/Java%E4%B8%ADDuration%E7%B1%BB%E5%92%8CPeriod%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"说明Duration类通过秒和纳秒相结合来描述一个时间量，最高精度是纳秒。时间量可以为正也可以为负，比如1天（86400秒0纳秒）、-1天（-86400秒0纳秒）、1年（31556952秒0纳秒）、1毫秒（0秒1000000纳秒）等。 Period类通过年、月、日相结合来描述一个时间量，最高精度是天。时间量可以为正也可以为负，例如2年（2年0个月0天）、3个月（0年3个月0天）、4天（0年0月4天）等。 这两个类是不可变的、线程安全的、最终类。都是JDK8新增的。 Duration创建方法通过时间单位创建基于天、时、分、秒、纳秒创建。 ofDays(), ofHours(), ofMillis(), ofMinutes(), ofNanos(), ofSeconds()。例如： 1Duration fromDays = Duration.ofDays(1); 通过LocalDateTime或LocalTime通过LocalDateTime或者LocalTime 类，然后使用between获取创建Duration。 1234LocalDateTime start = LocalDateTime.of(2022, 1, 1, 8, 0, 0);LocalDateTime end = LocalDateTime.of(2022, 1, 2, 8, 30, 30);// 表示两个时间的相差时间Duration duration = Duration.between(start, end); 通过已有的Duration12Duration du1 = Duration.ofHours(10);Duration duration = Duration.from(du1); 解析方法用法示例 12Duration fromChar1 = Duration.parse(&quot;P1DT1H10M10.5S&quot;);Duration fromChar2 = Duration.parse(&quot;PT10M&quot;); 格式说明 采用ISO-8601时间格式。格式为：PnYnMnDTnHnMnS （n为个数） 例如：P1Y2M10DT2H30M15.03S P：开始标记 1Y：一年 2M：两个月 10D：十天 T：日期和时间的分割标记 2H：两个小时 30M：三十分钟 15S：15.02秒 详解 1.”P”, “D”, “H”, “M” 和 “S”可以是大写或者小写（建议大写） 2.可以用“-”表示负数 示例 12345678&quot;PT20.345S&quot; -- parses as &quot;20.345 seconds&quot;&quot;PT15M&quot; -- parses as &quot;15 minutes&quot; (where a minute is 60 seconds)&quot;PT10H&quot; -- parses as &quot;10 hours&quot; (where an hour is 3600 seconds)&quot;P2D&quot; -- parses as &quot;2 days&quot; (where a day is 24 hours or 86400 seconds)&quot;P2DT3H4M&quot; -- parses as &quot;2 days, 3 hours and 4 minutes&quot;&quot;P-6H3M&quot; -- parses as &quot;-6 hours and +3 minutes&quot;&quot;-P6H3M&quot; -- parses as &quot;-6 hours and -3 minutes&quot;&quot;-P-6H+3M&quot; -- parses as &quot;+6 hours and -3 minutes&quot; 常用API方法比较两个时间差1234567891011Instant start = Instant.parse(&quot;2023-01-03T10:15:30.00Z&quot;);Instant end = Instant.parse(&quot;2023-01-04T10:15:30.00Z&quot;);// end - startDuration duration = Duration.between(start, end);// 任何一个时间单元为负数，则返回trueSystem.out.println(&quot;是否为负数:&quot; + duration.isNegative());// 转换为秒，最高精度是纳秒System.out.println(&quot;秒:&quot; + duration.getSeconds());System.out.println(&quot;纳秒:&quot; + duration.getNano()); 增减方法 plusXxx()、minusXxx()增减包括：days, hours, millis, minutes, nanos 或 seconds 123Duration duration = Duration.ofHours(2);// 在原有基础上增加30秒Duration newDuration = duration.plusSeconds(30); 转换单位 toXxx()可以用toXxx来转换为其他单位，支持：toDays, toHours, toMinutes, toMillis, toNanos 1234567Duration duration = Duration.ofHours(2); duration.toDays(); // 0duration.toHours(); // 2duration.toMinutes(); // 120duration.toMillis(); // 7200000duration.toNanos(); // 7200000000000 取值方法可以用getXxx来获得指定位置的值，因为Duration是由秒和纳秒组成，所以只能获得秒和纳秒： 123Duration duration = Duration.ofHours(2);duration.getSeconds(); // 7200duration.getNano(); // 0 Period创建方法通过时间单位创建如果仅一个值表示，如使用ofDays()方法，那么其他值为0。 若仅用ofWeeks，则其天数为week数乘以7. 12345Period fromUnits = Period.of(3, 10, 10);Period fromDays = Period.ofDays(50);Period fromMonths = Period.ofMonths(5);Period fromYears = Period.ofYears(10);Period fromWeeks = Period.ofWeeks(40); //280天 通过LocalDate创建1234LocalDate startDate = LocalDate.of(2015, 2, 20);LocalDate endDate = LocalDate.of(2017, 1, 15);// startDate减endDatePeriod period = Period.between(startDate, endDate); 解析方法格式：“PnYnMnWnD” P：开始符，表示period（即：表示年月日）； Y：year； M：month； W：week； D：day P, Y, M, W, D都可以用大写或者小写。 123Period period = Period.parse(&quot;P2Y&quot;); //2年Period period = Period.parse(&quot;P2Y3M5D&quot;); //2年3月5天Period period = Period.parse(&quot;P1Y2M3W4D&quot;); // 1年2月3周4天。即：1年2月25天 常用API方法比较方法用between来比较日期。 123456LocalDate startDate = LocalDate.of(2015, 2, 20);LocalDate endDate = LocalDate.of(2017, 1, 15); // endDate - startDatePeriod period = Period.between(startDate, endDate);// 任何一个时间单元为负数则返回trueperiod.isNegative() 增减方法 plusXxx()、minusXxx()123Period period = Period.parse(&quot;P2Y3M5D&quot;);period.plusDays(50);period.minusMonths(2); 转换单位 toXxx()12Period period = Period.parse(&quot;P1Y2M3D&quot;);period.toTotalMonths(); // 14 取值方法1234Period period = Period.parse(&quot;P1Y2M3D&quot;);period.getYears(); // 1period.getMonths(); // 2period.getDays(); // 3","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}],"author":["extends"]},{"title":"mybatisplus快速配置使用","slug":"mybatisplus快速配置使用","date":"2023-03-18T05:21:05.000Z","updated":"2023-03-18T05:23:48.053Z","comments":true,"path":"2023/03/18/mybatisplus快速配置使用/","link":"","permalink":"http://example.com/2023/03/18/mybatisplus%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1. 引入maven依赖123456&lt;!-- mybatis-plus --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt; starter包中已经包括mybatis依赖，只需要引入一个starter包即可。 2. 配置配置yaml文件 123456789101112131415161718spring: application: name: xiaoyi datasource: url: jdbc:mysql://192.168.13.130:3306/oauth_admin?useUnicode=TRUE&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;serverTimezone=UTC&amp;useSSL=false type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver username: root password: rootmybatis-plus: global-config: db-config: id-type: auto configuration: map-underscore-to-camel-case: true auto-mapping-behavior: full log-impl: org.apache.ibatis.logging.stdout.StdOutImpl mapper-locations: classpath:mapper/*.xml 创建配置类，配置mybatisplus的分页插件。 1234567@Configurationpublic class MybatisPlusConfig &#123; @Bean public PaginationInterceptor paginationInterceptor()&#123; return new PaginationInterceptor(); &#125;&#125; 3. 编写实体类抽离公共字段，编写BaseEntity其他业务类继承该基础类。 BaseEntity.java 1234567891011121314151617181920212223242526272829303132333435363738import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.fasterxml.jackson.annotation.JsonFormat;import com.fasterxml.jackson.databind.annotation.JsonSerialize;import lombok.Data;import java.io.Serializable;import java.util.Date;@Data// 实现序列化接口public class BaseEntity implements Serializable &#123; @TableField(exist = false) private static final long serialVersionUID = 1L; @TableId(value = &quot;id&quot;, type = IdType.AUTO) private Long id; /** * 创建日期 */ @JsonSerialize(using=CustomDateTimeSerializer.class) @JsonFormat(pattern =&quot;yyyy-MM-dd HH:mm:ss&quot;) private Date createTime; /** * 更新日期 */ @JsonSerialize(using=CustomDateTimeSerializer.class) @JsonFormat(pattern =&quot;yyyy-MM-dd HH:mm:ss&quot;) private Date updateTime; /** * 备注 */ @TableField(value = &quot;remark&quot;) private String remark;&#125; SysRole.java 123456789101112131415161718192021222324import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;/** * @TableName sys_role */@TableName(value =&quot;sys_role&quot;)@Datapublic class SysRole extends BaseEntity &#123; /** * 角色名称 */ @TableField(value = &quot;name&quot;) private String name; /** * 角色权限字符串 */ @TableField(value = &quot;code&quot;) private String code;&#125; 3. 编写Mapper层mapper层接口需要继承BaseMapper&lt;SysRole&gt;，泛型为对应的实体类对象。 1234import com.xiaoyi.entity.SysRole;import com.baomidou.mybatisplus.core.mapper.BaseMapper;public interface SysRoleMapper extends BaseMapper&lt;SysRole&gt; &#123;&#125; 4. 编写Service层service层需要继承ServiceImpl&lt;SysRoleMapper, SysRole&gt;类，泛型分别为对应的mapper接口和实体类对象。 1234567891011import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.xiaoyi.entity.SysRole;import com.xiaoyi.service.SysRoleService;import com.xiaoyi.mapper.SysRoleMapper;import org.springframework.stereotype.Service;@Servicepublic class SysRoleServiceImpl extends ServiceImpl&lt;SysRoleMapper, SysRole&gt; implements SysRoleService&#123;&#125; 5. 编写Controller并测试编写接口调用测试是否成功。 123456789101112131415161718192021222324252627282930313233343536373839404142import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.xiaoyi.entity.*;import com.xiaoyi.service.SysRoleMenuService;import com.xiaoyi.service.SysRoleService;import org.springframework.security.access.prepost.PreAuthorize;import org.springframework.transaction.annotation.Transactional;import org.springframework.util.StringUtils;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;import java.util.*;import java.util.stream.Collectors;@RestController@RequestMapping(&quot;/sys/role&quot;)public class SysRoleController &#123; @Resource private SysRoleService roleService; /** * @description 分页查询角色 * @param pageBean 分页 * @return com.xiaoyi.entity.ResultBody * @author 小易 * @date 2022/12/16 13:41 */ @GetMapping(&quot;/list&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system:role:query&#x27;)&quot;) public ResultBody list(PageBean pageBean)&#123; String query = pageBean.getQuery(); Page&lt;SysRole&gt; page = roleService.page( new Page&lt;&gt;(pageBean.getPageNum(), pageBean.getPageSize()), new QueryWrapper&lt;SysRole&gt;().like(StringUtils.hasText(query),&quot;name&quot;,query)); List&lt;SysRole&gt; roleList = page.getRecords(); Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;(); resultMap.put(&quot;roleList&quot;, roleList); resultMap.put(&quot;total&quot;, page.getTotal()); return ResultBody.success(resultMap); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://example.com/tags/mybatis/"}],"author":["extends"]},{"title":"# springboot解决中文乱码","slug":"springboot解决中文乱码","date":"2023-03-16T09:03:23.000Z","updated":"2023-03-18T05:24:01.809Z","comments":true,"path":"2023/03/16/springboot解决中文乱码/","link":"","permalink":"http://example.com/2023/03/16/springboot%E8%A7%A3%E5%86%B3%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","excerpt":"","text":"通过实现WebMvcConfigurer，重写configureMessageConverters方法，自定义转换器。 123456789@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; StringHttpMessageConverter converter = new StringHttpMessageConverter(Charset.forName(&quot;UTF-8&quot;)); converters.add(converter); &#125;&#125; 通过继承WebMvcConfigurationSupport 123456789@Configurationpublic class MyTestConfig extends WebMvcConfigurationSupport &#123; @Override protected void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; StringHttpMessageConverter converter = new StringHttpMessageConverter(StandardCharsets.UTF_8); converters.add(converter); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://example.com/tags/springboot/"}],"author":["extends"]},{"title":"swagger配置教程","slug":"swagger配置教程","date":"2023-03-08T03:16:05.000Z","updated":"2023-03-08T03:17:07.709Z","comments":true,"path":"2023/03/08/swagger配置教程/","link":"","permalink":"http://example.com/2023/03/08/swagger%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/","excerpt":"","text":"实时接口文档就是可以根据代码来自动生成相应的接口文档，优点就是我们的代码发生变化时，生成的接口文档也会自动更新，无需我们去修改接口文档，只需要按时发布即可。但是由于是根据代码自动生成的，所以最大的弊端就是代码侵入性强，需要我们在项目代码中集成生成接口文档的相关代码。 SpringBoot集成swagger2引入依赖12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 引入配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.ParameterBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.schema.ModelRef;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Parameter;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;import java.util.ArrayList;import java.util.List;@Configuration// 该注解必须开启，也可以在spring启动类上开启@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket createRestApi() &#123; // Docket配置，就是一组(一个项目或一个版本)接口文档的配置，比如设置名称， 联系人等 return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() // 扫描路径下的所有类 .apis(RequestHandlerSelectors.basePackage(&quot;com.swagger.springboot_swagger_dome.controller&quot;)) .paths(PathSelectors.any()) .build() .globalOperationParameters(setHeaderToken()); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;action-swagger&quot;) .description(&quot;swagger实战&quot;) .termsOfServiceUrl(&quot;&quot;) .version(&quot;1.0&quot;) .build(); &#125; /** * 设置swagger文档中全局参数，所有接口中都要包含一个header类型的token参数 */ private List&lt;Parameter&gt; setHeaderToken() &#123; List&lt;Parameter&gt; pars = new ArrayList&lt;&gt;(); ParameterBuilder userId = new ParameterBuilder(); userId.name(&quot;token&quot;).description(&quot;用户TOKEN&quot;).modelRef(new ModelRef(&quot;string&quot;)).parameterType(&quot;header&quot;) .required(true).build(); pars.add(userId.build()); return pars; &#125;&#125; 给Controller 添加注解接口文档的直接描述主要就是在Controller这一层，比如这个接口的功能，参数的名称，返回值的名称等。这些值我们都需要在Controller上通过给方法上，请求参数和返回参数上添加对应的注解，swagger才能帮我们生成相应的接口文档。 请求类 1234567891011121314151617import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;@Data@ApiModel(&quot;创建Swagger请求参数&quot;)public class SwaggerReqVO &#123; @ApiModelProperty(&quot;id&quot;) private Integer id; @ApiModelProperty(&quot;姓名&quot;) private String name; @ApiModelProperty(&quot;性别&quot;) private Integer gender;&#125; 响应类 1234567891011121314151617181920import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;@Data@ApiModel(&quot;创建Swagger响应结果&quot;)public class SwaggerResVO &#123; @ApiModelProperty(&quot;id&quot;) private Integer id; @ApiModelProperty(&quot;姓名&quot;) private String name; @ApiModelProperty(&quot;性别&quot;) private Integer gender; @ApiModelProperty(&quot;嘛&quot;) private String what;&#125; Controller 1234567891011121314151617181920212223import com.swagger.springboot_swagger_dome.vo.SwaggerReqVO;import com.swagger.springboot_swagger_dome.vo.SwaggerResVO;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(&quot;/swagger&quot;)@Api(value = &quot;用户接口&quot;, tags = &#123;&quot;用户接口&quot;&#125;)public class SwaggerController &#123; @ApiOperation(&quot;新增用户&quot;) @PostMapping(&quot;save&quot;) public String save(@RequestBody SwaggerReqVO req) &#123; return &quot;success&quot;; &#125; @GetMapping(&quot;getById&quot;) @ApiOperation(&quot;根据条件查询用户&quot;) public SwaggerResVO getById(@RequestBody SwaggerResVO req) &#123; return new SwaggerResVO(); &#125;&#125; 访问地址： ip:端口号&#x2F;swagger-ui.html 可能出现的问题可能会出现以下错误：org.springframework.context.ApplicationContextException: Failed to start bean &#39;documentationPluginsBootstrapper&#39;; 12345678910111213141516org.springframework.context.ApplicationContextException: Failed to start bean &#x27;documentationPluginsBootstrapper&#x27;; nested exception is java.lang.NullPointerException at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:181) ~[spring-context-5.3.25.jar:5.3.25] at org.springframework.context.support.DefaultLifecycleProcessor.access$200(DefaultLifecycleProcessor.java:54) ~[spring-context-5.3.25.jar:5.3.25] at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:356) ~[spring-context-5.3.25.jar:5.3.25] at java.base/java.lang.Iterable.forEach(Iterable.java:75) ~[na:na] at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:155) ~[spring-context-5.3.25.jar:5.3.25] at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:123) ~[spring-context-5.3.25.jar:5.3.25] at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:935) ~[spring-context-5.3.25.jar:5.3.25] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:586) ~[spring-context-5.3.25.jar:5.3.25] at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:147) ~[spring-boot-2.7.8.jar:2.7.8] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:731) ~[spring-boot-2.7.8.jar:2.7.8] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:408) ~[spring-boot-2.7.8.jar:2.7.8] at org.springframework.boot.SpringApplication.run(SpringApplication.java:307) ~[spring-boot-2.7.8.jar:2.7.8] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1303) ~[spring-boot-2.7.8.jar:2.7.8] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1292) ~[spring-boot-2.7.8.jar:2.7.8] at com.swagger.springboot_swagger_dome.SpringbootSwaggerDomeApplication.main(SpringbootSwaggerDomeApplication.java:10) ~[classes/:na] 这个问题的主要原因确实是SpringBoot版本过高导致。如果用的是SpringBoot2.5.x及之前版本是没有问题的。 Spring Boot 2.6.X使用PathPatternMatcher匹配路径，Swagger引用的Springfox使用的路径匹配是基于AntPathMatcher的。 所以要想解决，添加配置，将springBoot MVC的路劲匹配模式修改一下即可。 1spring.mvc.pathmatch.matching-strategy=ANT_PATH_MATCHER 1234spring: mvc: pathmatch: matching-strategy: ANT_PATH_MATCHER swagger常用注解1、**@Api()**：用在请求的类上，表示对类的说明，也代表了这个类是swagger2的资源 参数： 123tags：说明该类的作用，参数是个数组，可以填多个。value=&quot;该参数没什么意义，在UI界面上不显示，所以不用配置&quot;description = &quot;用户基本信息操作&quot; 2、**@ApiOperation()**：用于方法，表示一个http请求访问该方法的操作 参数： 12345value=&quot;方法的用途和作用&quot; notes=&quot;方法的注意事项和备注&quot; tags：说明该方法的作用，参数是个数组，可以填多个。格式：tags=&#123;&quot;作用1&quot;,&quot;作用2&quot;&#125; （在这里建议不使用这个参数，会使界面看上去有点乱，前两个常用） 3、**@ApiModel()**：用于响应实体类上，用于说明实体作用 参数： 1description=&quot;描述实体的作用&quot; 4、**@ApiModelProperty**：用在属性上，描述实体类的属性 参数： 123value=&quot;用户名&quot; 描述参数的意义name=&quot;name&quot; 参数的变量名required=true 参数是否必选 5、**@ApiImplicitParams**：用在请求的方法上，包含多@ApiImplicitParam 6、**@ApiImplicitParam**：用于方法，表示单独的请求参数 参数： 1234567891011name=&quot;参数ming&quot; value=&quot;参数说明&quot; dataType=&quot;数据类型&quot; paramType=&quot;query&quot; 表示参数放在哪里 · header 请求参数的获取：@RequestHeader · query 请求参数的获取：@RequestParam · path（用于restful接口） 请求参数的获取：@PathVariable · body（不常用） · form（不常用） defaultValue=&quot;参数的默认值&quot;required=&quot;true&quot; 表示参数是否必须传 7、**@ApiParam()**：用于方法，参数，字段说明 表示对参数的要求和说明 参数： 1234name=&quot;参数名称&quot;value=&quot;参数的简要说明&quot;defaultValue=&quot;参数默认值&quot;required=&quot;true&quot; 表示属性是否必填，默认为false 8、**@ApiResponses**：用于请求的方法上，根据响应码表示不同响应 一个@ApiResponses包含多个@ApiResponse 9、**@ApiResponse**：用在请求的方法上，表示不同的响应 参数： 12code=&quot;404&quot; 表示响应码(int型)，可自定义message=&quot;状态码对应的响应信息&quot; 10、**@ApiIgnore()**：用于类或者方法上，不被显示在页面上 11、**@Profile({“dev”, “test”})**：用于配置类上，表示只对开发和测试环境有用","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"swagger","slug":"swagger","permalink":"http://example.com/tags/swagger/"}],"author":["extends"]},{"title":"前后端分离项目跨域问题","slug":"前后端分离项目跨域问题","date":"2023-01-03T08:43:54.000Z","updated":"2023-01-03T09:31:25.000Z","comments":true,"path":"2023/01/03/前后端分离项目跨域问题/","link":"","permalink":"http://example.com/2023/01/03/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"方法一：SpringBoot后端进行处理在 每个 Controller 类上加入 @CrossOrigin 注解 或者 在 Controller的基类中加上 @CrossOrigin 注解然后其他 Controller 类就有了这个 @Controller此时跨域访问就不会报错了。 方法二：在Vue前端进行处理浏览器 在同一个页面访问不同的域 是存在跨域问题的 但 服务器之间的访问是 没有跨域问题 因此 需要在前端设置代理， 通过代理访问 SpringBoot后端API 安装代理 1cnpm install --save-dev http-proxy-middleware 配置请求 baseURL 在 src &#x2F; utils &#x2F; request.js 中 12345678910// 创建axios实例const service = axios.create(&#123; // axios中请求配置有baseURL选项，表示请求URL公共部分 // baseURL: &#x27;http://127.0.0.1:8888/ruoyi&#x27;, baseURL: &#x27;/api&#x27;, // changeOrigin: true, // 超时 timeout: 10000&#125;) 配置 proxy 在 vue.config.js 中 1234567891011121314151617module.exports = &#123; devServer: &#123; // 自动打开浏览器 open: true, port: 70, proxy: &#123; // // detail: https://cli.vuejs.org/config/#devserver-proxy &#x27;/api&#x27;: &#123; target: `http://localhost:8888/ruoyi`, changeOrigin: true, pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125; &#125; &#125; &#125;&#125; login.vue 页面发送验证码的请求 请求 API 12345678import request from &#x27;@/utils/request&#x27;// 获取验证码export function getCodeImg() &#123; return request(&#123; url: &#x27;/captcha/captchaImage?type=math&#x27;, method: &#x27;get&#x27; &#125;)&#125; 总结 跨域解决方案有很多种，如 使用 nginx代理 使用 filter 添加头信息 使用 @CrossOrigin 注解 使用 proxy 代理","categories":[{"name":"前后端","slug":"前后端","permalink":"http://example.com/categories/%E5%89%8D%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF/"}],"author":["extends"]},{"title":"axios发post请求，后端接收不到参数的解决方案","slug":"axios发post请求，后端接收不到参数的解决方案","date":"2022-12-12T09:51:18.000Z","updated":"2023-01-03T09:31:39.000Z","comments":true,"path":"2022/12/12/axios发post请求，后端接收不到参数的解决方案/","link":"","permalink":"http://example.com/2022/12/12/axios%E5%8F%91post%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%90%8E%E7%AB%AF%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%88%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"问题原因原因就是这次的接口使用 java spring mvc并且在这个方法上使用了注解 @RequestParam 这个是只能从请求的地址中取出参数，也就是只能从 username&#x3D;admin&amp;password&#x3D;admin 这种字符串中解析出参数。我们还可以看到我们这次请求的 Content-Type : 1application/json;charset=UTF-8 axios会帮我们 转换请求数据和响应数据 以及 自动转换 JSON 数据 问题分析也就是说，我们的 Content-Type 变成了 application/json;charset=utf-8然后，因为我们的参数是 JSON 对象，axios 帮我们做了一个 stringify 的处理。而且查阅 axios 文档可以知道：axios 使用 post 发送数据时，默认是直接把 json 放到请求体中提交到后端的。 那么，这就与我们服务端要求的 &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39; 以及 @RequestParam 不符合。 解决方案一【用 URLSearchParams 传递参数】 12345678let param = new URLSearchParams()param.append(&#x27;username&#x27;, &#x27;admin&#x27;)param.append(&#x27;pwd&#x27;, &#x27;admin&#x27;)axios(&#123; method: &#x27;post&#x27;, url: &#x27;/api/lockServer/search&#x27;, data: param&#125;) 需要注意的是： URLSearchParams 不支持所有的浏览器，但是总体的支持情况还是 OK 的，所以优先推荐这种简单直接的解决方案 解决方案二【还需要额外的操作，（我们要将参数转换为query参数）】引入 qs ，这个库是 axios 里面包含的，不需要再下载了。 1234567891011121314import Qs from &#x27;qs&#x27;let data = &#123; &quot;username&quot;: &quot;admin&quot;, &quot;pwd&quot;: &quot;admin&quot;&#125;axios(&#123; headers: &#123; &#x27;deviceCode&#x27;: &#x27;A95ZEF1-47B5-AC90BF3&#x27; &#125;, method: &#x27;post&#x27;, url: &#x27;/api/lockServer/search&#x27;, data: Qs.stringify(data)&#125;) 解决方案三 我们知道现在我们服务端同学接收参数用的是 @RequestParam（通过字符串中解析出参数）其实还有另一种是 @RequestBody（从请求体中获取参数）。 后端改成 @RequestBody 就可以了","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"前端/axios","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/axios/"}],"tags":[{"name":"axios","slug":"axios","permalink":"http://example.com/tags/axios/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}],"author":["extends"]},{"title":"axios发送四种请求方式","slug":"axios发送四种请求方式","date":"2022-12-12T09:31:20.000Z","updated":"2023-01-03T09:31:35.000Z","comments":true,"path":"2022/12/12/axios发送四种请求方式/","link":"","permalink":"http://example.com/2022/12/12/axios%E5%8F%91%E9%80%81%E5%9B%9B%E7%A7%8D%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/","excerpt":"","text":"get和 delete请求传递参数 通过传统的url 以 ? 的形式传递参数 restful 形式传递参数 通过params 形式传递参数 post 和 put 请求传递参数 通过选项传递参数 通过 URLSearchParams 传递参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 1. 发送get 请求 axios.get(&#x27;http://localhost:3000/adata&#x27;).then(function(ret)&#123; // 拿到 ret 是一个对象 所有的对象都存在 ret 的data 属性里面 // 注意data属性是固定的用法，用于获取后台的实际数据 // console.log(ret.data) console.log(ret)&#125;)// 2. get 请求传递参数// 2.1 通过传统的url 以 ? 的形式传递参数axios.get(&#x27;http://localhost:3000/axios?id=123&#x27;).then(function(ret)&#123; console.log(ret.data)&#125;)// 2.2 restful 形式传递参数 axios.get(&#x27;http://localhost:3000/axios/123&#x27;).then(function(ret)&#123; console.log(ret.data)&#125;)// 2.3 通过params 形式传递参数 axios.get(&#x27;http://localhost:3000/axios&#x27;, &#123; params: &#123; id: 789 &#125;&#125;).then(function(ret)&#123; console.log(ret.data)&#125;)// 3 axios delete 请求传参 传参的形式和 get 请求一样axios.delete(&#x27;http://localhost:3000/axios&#x27;, &#123; params: &#123; id: 111 &#125;&#125;).then(function(ret)&#123; console.log(ret.data)&#125;)// 4 axios 的 post 请求// 4.1 通过选项传递参数axios.post(&#x27;http://localhost:3000/axios&#x27;, &#123; uname: &#x27;lisi&#x27;, pwd: 123&#125;).then(function(ret)&#123; console.log(ret.data)&#125;)// 4.2 通过 URLSearchParams 传递参数 var params = new URLSearchParams();params.append(&#x27;uname&#x27;, &#x27;zhangsan&#x27;);params.append(&#x27;pwd&#x27;, &#x27;111&#x27;);axios.post(&#x27;http://localhost:3000/axios&#x27;, params).then(function(ret)&#123; console.log(ret.data)&#125;)// 5 axios put 请求传参 和 post 请求一样 axios.put(&#x27;http://localhost:3000/axios/123&#x27;, &#123; uname: &#x27;lisi&#x27;, pwd: 123&#125;).then(function(ret)&#123; console.log(ret.data)&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"前端/axios","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/axios/"}],"tags":[{"name":"axios","slug":"axios","permalink":"http://example.com/tags/axios/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}],"author":["extends"]},{"title":"docker笔记","slug":"docker笔记","date":"2022-12-09T08:14:47.000Z","updated":"2023-01-03T09:31:46.000Z","comments":true,"path":"2022/12/09/docker笔记/","link":"","permalink":"http://example.com/2022/12/09/docker%E7%AC%94%E8%AE%B0/","excerpt":"","text":"安装dockerDocker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。 Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。 所以，Docker 必须部署在 Linux 内核的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。 Linux系统安装与卸载使用官方安装脚本自动安装安装命令如下： 1curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 也可以使用国内 daocloud 一键安装命令： 1curl -sSL https://get.daocloud.io/docker | sh curl是一个利用 URL 语法，在终端下使用的网络请求工具，支持 HTTP、HTTPS、FTP 等协议。CURL 也有用于程序开发使用的版本 libcurl。 Linux、MAC 一般系统默认已安装好 curl，直接在终端使用命令即可，如果需要手动安装，可以到 curl.haxx.se 下载安装。 卸载 docker删除安装包： 1yum remove docker-ce 删除镜像、容器、配置文件等内容： 1rm -rf /var/lib/docker 使用docker命令基本上都是以docker开头。 docker要运行首先需要有一个镜像(images)，通过镜像创建容器，之后在容器中即可进行自己的操作。 这一点可以理解为java中首先需要有一个类，然后通过new 类名 的方式创建出这个类的实例之后才可以使用这个类一样。 Docker命令一览图 &#x3D;&#x3D;使用docker镜像可以到dockerhub上搜索查询某一镜像的使用方法&#x3D;&#x3D; https://hub.docker.com/ Docker原理理解一、镜像是什么​ 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。所有的应用，直接打包docker镜像，就可以直接跑起来！如何得到镜像： 从远程仓库下载 朋友拷贝给你 自己制作一个镜像DockerFile 二、Docker镜像加速原理UnionFS（联合文件系统） 我们下载的时候看到的一层层就是这个！UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union 文件系统是Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。 Docker镜像加载原型 docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。 bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。 rootfs（root file system），在bootfs之上。包含的就是典型Linux系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。（虚拟机是分钟级，容器是秒级！） 三、分层理解分层的镜像 下载一个镜像，观察其下载的日志输出，可以看到是一层一层的在下载！ 思考：为什么Docker镜像要采用这种分层的结构呢？最大的好处，我觉得莫过于是资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。查看镜像分层的方式可以通过 docker image inspect命令！ 123456789101112131415161718[ // ...... &quot;RootFS&quot;: &#123; &quot;Type&quot;: &quot;layers&quot;, &quot;Layers&quot;: [ &quot;sha256:2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f&quot;, &quot;sha256:9b24afeb7c2f21e50a686ead025823cd2c6e9730c013ca77ad5f115c079b57cb&quot;, &quot;sha256:4b8e2801e0f956a4220c32e2c8b0a590e6f9bd2420ec65453685246b82766ea1&quot;, &quot;sha256:529cdb636f61e95ab91a62a51526a84fd7314d6aab0d414040796150b4522372&quot;, &quot;sha256:9975392591f2777d6bf4d9919ad1b2c9afa12f9a9b4d260f45025ec3cc9b18ed&quot;, &quot;sha256:8e5669d8329116b8444b9bbb1663dda568ede12d3dbcce950199b582f6e94952&quot; ] &#125;, &quot;Metadata&quot;: &#123; &quot;LastTagTime&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125; &#125;] 理解：所有的Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。举一个简单的例子，假如基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。该镜像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。 在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。 上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版本。 这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。Linux上可用的存储引擎有AUFS、Overlay2、Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。Docker在Windows 上仅支持 windowsfilter一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW[1]。下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。 特点 Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！这一层就是我们通常说的容器层，容器之下的都叫镜像层！ 四、个人理解类似Git的版本控制 每次commit都是提交新改动，commit出来的新镜像就作为镜像层，运行该镜像时就会在添加一个可编辑的容器层。 Docker 镜像使用查看本地镜像当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。 使用指令docker images查看本地主机上的所有镜像。 123REPOSITORY TAG IMAGE ID CREATED SIZEredis latest 3358aea34e8c 2 weeks ago 117MBubuntu latest a8780b506fa4 4 weeks ago 77.8MB REPOSITORY：表示镜像的仓库源 TAG：镜像的标签 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 使用镜像使用指令docker run -t -i ubuntu[:指定版本] /bin/bash 运行容器 -i: 交互式操作。 -t: 终端。 ubuntu:[15.10]: 这是指用 ubuntu 15.10 版本镜像为基础来启动容器。 &#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。 1$ docker run -t -i ubuntu:15.10 /bin/bash 下载新镜像使用指令docker pull [需要下载的镜像:版本]下载指定镜像。 1$ docker pull ubuntu:13.10 删除镜像使用指令docker rmi [镜像名称]删除指定镜像 1$ docker rmi ubuntu:15.10 创建镜像当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。 1、从已经创建的容器中更新镜像，并且提交这个镜像 2、使用 Dockerfile 指令来创建一个新的镜像 更新镜像更新镜像之前，我们需要使用镜像来创建一个容器。 1$ docker run -t -i ubuntu:15.10 /bin/bash 在运行的容器内使用 apt-get update 命令进行更新。 在完成操作之后，输入 exit 命令来退出这个容器。 此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。 1$ docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2 各个参数说明： -m: 提交的描述信息 -a: 指定镜像作者 e218edb10161：容器 ID runoob&#x2F;ubuntu:v2: 指定要创建的目标镜像名 我们可以使用 docker images 命令来查看我们的新镜像 runoob&#x2F;ubuntu:v2： 1234567891011runoob@runoob:~$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZErunoob/ubuntu v2 70bf1840fd7c 15 seconds ago 158.5 MBubuntu 14.04 90d5884b1ee0 5 days ago 188 MBphp 5.6 f40e9e0f10c8 9 days ago 444.8 MBnginx latest 6f8d099c3adc 12 days ago 182.7 MBmysql 5.6 f2e8d6c772c0 3 weeks ago 324.6 MBhttpd latest 02ef73cf1bc0 3 weeks ago 194.4 MBubuntu 15.10 4e3b13c8a266 4 weeks ago 136.3 MBhello-world latest 690ed74de00f 6 months ago 960 Btraining/webapp latest 6fae60ef3446 12 months ago 348.8 MB 使用我们的新镜像 runoob&#x2F;ubuntu 来启动一个容器 1runoob@runoob:~$ docker run -t -i runoob/ubuntu:v2 /bin/bash Docker 容器使用启动容器使用指令docker run -itd ubuntu /bin/bash启动一个容器。 -i: 交互式操作。 -t: 终端。 -d: 后台运行。 ubuntu: ubuntu 镜像。 &#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。 查看容器1$ docker ps -a 启动已停止的容器1$ docker start [容器id | 容器名称] 停止容器1$ docker stop &lt;容器名称 | ID&gt; 进入容器在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入： docker attach docker exec：推荐使用 ，此命令在退出容器终端时不会导致容器停止。 attach 命令 1$ docker attach 1e560fca3906 注意： 如果从这个容器退出，会导致容器的停止。 exec 命令 1$ docker exec -it 243c32535da7 /bin/bash 删除容器删除容器使用 docker rm 命令： 1$ docker rm -f 1e560fca3906 导出和导入容器导出容器 如果要导出本地某个容器，可以使用 docker export 命令。 1$ docker export 1e560fca3906 &gt; ubuntu.tar 导出容器 1e560fca3906 快照到本地文件 ubuntu.tar。 导入容器快照 可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test&#x2F;ubuntu:v1: 1$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1 也可以通过指定 URL 或者某个目录来导入，例如： 1$ docker import http://example.com/exampleimage.tgz example/imagerepo Docker 容器数据卷当容器删除时，容器中的数据也会一并删除，需要将需要的数据持久化到宿主机上（例如：需要将MySQL的数据库文件保存下来） 容器数据卷就是解决这个问题的，它可以将容器内的目录挂载到宿主机上，实现实时同步该目录下的所有文件 【PS : 类似vue的双向绑定，容器目录中的文件改动时宿主机目录中的文件也会变动，同理宿主机改动目录中文件，容器目录中的文件也会变动】 &#x3D;&#x3D;容器的持久化和同步操作！容器间也可以实现数据共享&#x3D;&#x3D; 使用 指令： 1$ docker run -it -v 主机目录:容器内目录 镜像名 /bin/bash 只要容器还存在，绑定的目录就会始终同步，不论容器是否运行中。 匿名挂载和具名挂载 所有的docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/xxxx/_data&quot;（xxxx是卷名）路径下 指定名字进行挂载就是具名挂载，不指定名字会随机生成一个 12345678910111213141516# 匿名挂载docker run -d -p --name nginx01 -v /etc/nginx nginx# 查看所有的volume的情况[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker volume lsDRIVER VOLUME NAMElocal 964b8e505f12f65fb23fd21f05cfa9ecd6c2c6b2ca89c0e44f168bb017dfabd6# 这种就是匿名挂载：我们在-v挂载目录时，只写了容器内的路径，没有写容器外的路径。# 具名挂载[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker run -d -p 3344:80 --name nginx02 -v juming-nginx:/etc/nginx nginx[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker volume lsDRIVER VOLUME NAMElocal 964b8e505f12f65fb23fd21f05cfa9ecd6c2c6b2ca89c0e44f168bb017dfabd6local juming-nginx# 通过 -v 卷名:容器内的路径（具名挂载）# 查看一下这个卷 我们通过具名挂载可以方便的找到我们的一个卷大多数情况在使用的具名挂载 1234$ docker run -it -v xxx 镜像名 /bin/bash-v 容器内的路径 # 匿名挂载-v 卷名:容器内的路径 # 具名挂载-v /宿主机路径:容器内路径 # 指定路径挂载 拓展： 1234567# 通过 -v 容器内的路径:ro rw 改变读写权限ro read only # 只读rw read write # 可读可写# 一旦设置了容器权限，容器对我们挂载出来的内容就有了限定。docker run -d -p 3344:80 --name nginx02 -v juming-nginx:/etc/nginx:ro nginxdocker run -d -p 3344:80 --name nginx02 -v juming-nginx:/etc/nginx:rw nginx# 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！ Docker 容器连接容器中可以运行网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。 网络端口映射指令： 1$ docker run -d -P 镜像名:版本 [命令] 1$ docker run -itd --name 容器名称 -p 主机端口:容器端口 镜像名:版本 [命令] 放在镜像名后的是命令，例： 1$ docker run -itd --name redis-test -p 6379:6379 redis -P :是容器内部端口随机映射到主机的端口。 -p : 是容器内部端口绑定到指定的主机端口。 我们使用 -P 绑定端口号，使用 docker ps 可以看到容器端口 5000 绑定主机端口 32768。 123runoob@runoob:~$ docker psCONTAINER ID IMAGE COMMAND ... PORTS NAMESfce072cc88ce training/webapp &quot;python app.py&quot; ... 0.0.0.0:32768-&gt;5000/tcp grave_hopper 默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 &#x2F;udp。例： 1$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py docker port 命令可以快捷地查看端口的绑定情况。 12user@ubuntu:~$ docker port redis-test 63790.0.0.0:6379 Docker 网络容器互连docker每运行一个容器，就会创建两个虚拟网卡，通过这两个虚拟网卡连接到docker0网卡，docker0网卡扮演了路由的角色，负责转发请求，docker默认通过这种方式进行容器间的互相通信。所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用IP。 –link问题：希望可以使用名字来进行容器访问，达到切换ip服务仍然可用 12345678910111213# 通过服务名ping不通；如何解决？[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker exec -it tomcat02 ping tomcat01ping: tomcat01: Name or service not known# 通过--link可以解决网络连接问题。[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat:7.02393eecb870e5755068ea8b7d8bdcdd0f1ff110534c3359384413677c651bec4[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker exec -it tomcat03 ping tomcat02PING tomcat02 (172.17.0.3) 56(84) bytes of data.64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.085 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.055 ms# 反向可以ping通吗？（不可以）[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker exec -it tomcat02 ping tomcat03ping: tomcat03: Name or service not known 原因：其实就是tomcat03在本地配置了对应关系，访问tomcat02时映射到对应IP 12345678910# 查看[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker exec -it tomcat03 cat /etc/hosts127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.17.0.3 tomcat02 20398a94efa7172.17.0.4 2393eecb870e –link 就是我们在hosts配置中增加了一个”172.17.0.3 tomcat02 20398a94efa7”&#x3D;&#x3D;不建议使用–link&#x3D;&#x3D; 自定义网络所有docker网络 12345user@ubuntu:~$ docker network lsNETWORK ID NAME DRIVER SCOPEc74fcec8d1f2 bridge bridge local62d29c667f8a host host local726864d5969f none null local 网络模式： bridge：桥接 docker（默认，自己创建也使用bridge桥接模式） none：不配置网络 host：和主机共享网络 container：容器网络连通（用的少！局限很大） 创建网络 1234567user@ubuntu:~$ docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynetuser@ubuntu:~$ docker network lsNETWORK ID NAME DRIVER SCOPEc74fcec8d1f2 bridge bridge local62d29c667f8a host host localf55cb2fe8f6f mynet bridge local726864d5969f none null local 使用自己的网络 1user@ubuntu:~$ docker run -d -P --name tomcat-net-01 --net mynet tomcat:7.0 PS: 我们直接启动的命令–net bridge（这个就是我们的docker0）；docker会默认带上这个参数的，以下两种启动方式效果一致。 12docker run -d -P --name tomcat01 tomcatdocker run -d -P --name tomcato1 --het bridge tomcat 我们自定义的网络docker都已经帮我们维护好了对应的关系，可以直接使用名字ping通，推荐这样使用网络！ Docker Dockerfile简介Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。 流程： 创建Dockerfile文件 在文件中编写镜像构建命令 运行命令构建镜像 构建Dockerfile文件和要放入镜像中的文件需要放在同一目录下 使用指令执行构建操作 1$ docker build -t 镜像名:版本 上下文路径 示例 1$ docker build -t nginx:v3 . PS : 上下文路径就是一个路径，docker执行打包会将这个路径下的所有文件发送的docker服务端进行打包（ddocker是C&#x2F;S架构，打包操作是在服务端进行的） 示例1123456789101112131415161718# 构建镜像基于哪个镜像FROM anapsix/alpine-java:8_server-jre_unlimited# 镜像维护者姓名或邮箱地址MAINTAINER test@163.com# 构建镜像时运行的指令RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimeRUN mkdir -p /jero-boot# 这样执行run命令会创建两层镜像，可以使用 &amp;&amp; 连接命令# RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime# &amp;&amp; mkdir -p /jero-boot# 设置工作目录WORKDIR /jero-boot# 声明容器的服务端口EXPOSE 8080# 拷贝文件或目录到容器中ADD ./target/jero-boot-module-system-2.4.6.jar ./# 运行容器时执行的shell环境CMD sleep 60;java -Djava.security.egd=file:/dev/./urandom -jar jero-boot-module-system-2.4.6.jar Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。 示例2Dockerfile 1234567891011121314151617181920FROM centosMAINTAINER xiaoyi&lt;1393687715@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD apache-tomcat-9.0.70.tar.gz /usr/local/ADD jdk-8u351-linux-x64.tar.gz /usr/local/ENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_351ENV CLASS_PATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.70ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.70ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/bin:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.70/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.70/logs/catalina.out build 1docker run -d --name diytomcat01 -p 3355:8080 -v /home/user/Desktop/tomcat/test:/usr/local/apache-tomcat-9.0.70/webapps/test -v /home/user/Desktop/tomcat/tomcatlog:/usr/local/apache-tomcat-9.0.70/logs diytomcat 指令详解COPY复制指令，从上下文目录中复制文件或者目录到容器里指定路径。 格式： 12COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;... &lt;目标路径&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;] **[–chown&#x3D;:]**：可选参数，用户改变复制到容器内文件的拥有者和属组。 **&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如： 12COPY hom* /mydir/COPY hom?.txt /mydir/ **&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。 ADDADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下： ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。 ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。 CMD类似于 RUN 指令，用于运行程序，但二者运行的时间点不同: CMD 在docker run 时运行。 RUN 是在 docker build。 作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。 注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。 格式： 123CMD &lt;shell 命令&gt; CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数 推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。 ENTRYPOINT类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。 但是, 如果运行 docker run 时使用了 –entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。 优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。 注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。 格式： 1ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] 可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。 示例： 假设已通过 Dockerfile 构建了 nginx:test 镜像： 1234FROM nginxENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参 1、不传参运行 1$ docker run nginx:test 容器内会默认运行以下命令，启动主进程。 1$ nginx -c /etc/nginx/nginx.conf 2、传参运行 1$ docker run nginx:test -c /etc/nginx/new.conf 容器内会默认运行以下命令，启动主进程(&#x2F;etc&#x2F;nginx&#x2F;new.conf:假设容器内已有此文件) 1$ nginx -c /etc/nginx/new.conf ENV设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。 格式： 12ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;... 以下示例设置 NODE_VERSION &#x3D; 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用： 1234ENV NODE_VERSION 7.2.0RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; \\ &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot; ARG构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。 构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;&#x3D;&lt;值&gt; 来覆盖。 格式： 1ARG &lt;参数名&gt;[=&lt;默认值&gt;] VOLUME定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。 作用： 避免重要的数据，因容器重启而丢失，这是非常致命的。 避免容器不断变大。 格式： 12VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]VOLUME &lt;路径&gt; 在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。 EXPOSE仅仅只是声明端口。 作用： 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。 在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 格式： 1EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] WORKDIR指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。 docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。 格式： 1WORKDIR &lt;工作目录路径&gt; USER用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。 格式： 1USER &lt;用户名&gt;[:&lt;用户组&gt;] HEALTHCHECK用于指定某个程序或者指令来监控 docker 容器服务的运行状态。 格式： 123HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令HEALTHCHECK [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。 ONBUILD用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。 格式： 1ONBUILD &lt;其它指令&gt; LABELLABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下： 1LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ... 比如我们可以添加镜像的作者： 1LABEL org.opencontainers.image.authors=&quot;author&quot; Dockerfile指令简洁版 FROM 构建镜像基于哪个镜像 MAINTAINER 镜像维护者姓名或邮箱地址 RUN 构建镜像时运行的指令 CMD 运行容器时执行的shell环境 VOLUME 指定容器挂载点到宿主机自动生成的目录或其他容器 USER 为RUN、CMD、和 ENTRYPOINT 执行命令指定运行用户 WORKDIR 为 RUN、CMD、ENTRYPOINT、COPY 和 ADD 设置工作目录，就是切换目录 HEALTHCHECH 健康检查 ARG 构建时指定的一些参数 EXPOSE 声明容器的服务端口（仅仅是声明） ENV 设置容器环境变量 ADD 拷贝文件或目录到容器中，如果是URL或压缩包便会自动下载或自动解压 COPY 拷贝文件或目录到容器中，跟ADD类似，但不具备自动下载或解压的功能 ENTRYPOINT 运行容器时执行的shell命令 Docker Compose简介Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，可以使用 YML 文件来配置应用程序需要的所有服务。然后使用命令就可以从 YML 文件配置中创建并启动所有服务。 &#x2F;&#x2F; 暂时用不到","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"服务器","slug":"后端/服务器","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}],"author":["extends"]},{"title":"WebSocket前后端搭建","slug":"WebSocket前后端搭建","date":"2022-12-09T08:09:11.000Z","updated":"2023-01-03T09:31:58.000Z","comments":true,"path":"2022/12/09/WebSocket前后端搭建/","link":"","permalink":"http://example.com/2022/12/09/WebSocket%E5%89%8D%E5%90%8E%E7%AB%AF%E6%90%AD%E5%BB%BA/","excerpt":"","text":"简介WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 特点： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 对比传统实现服务器推送技术 ajax轮询 客户端每隔一段时间就发送一次请求，询问服务器是否有新消息 long poll long poll 原理和 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型。当客户端发起请求，服务端收到后如果没有新消息要发送给客户端的话就会等待，一直等待到有新消息再返回，如果时间超时，客户端收到超时的消息后会重新再发送一个请求。 实现流程 搭建后端服务器，初始化项目 创建配置类，注入ServerEndpointExporter对象 1234567@Configurationpublic class webSocketConfig &#123; @Bean public ServerEndpointExporter serverEndpointExporter()&#123; return new ServerEndpointExporter(); &#125;&#125; 创建WebSocketServer类，编写websocket服务。 12345678910111213141516171819202122232425@ServerEndpoint(&quot;/msgChannel/&#123;id&#125;&quot;)@Componentpublic class WebSocketServer &#123; @OnOpen public void open(@PathParam(&quot;id&quot;)String id, Session session)&#123; System.out.println(&quot;与[&quot;+id+&quot;]建立连接&quot;); &#125; @OnClose public void close() &#123; // 添加关闭会话时的操作 System.out.println(&quot;断开连接&quot;); &#125; @OnError public void error(Throwable t) &#123; // 添加处理错误的操作 t.printStackTrace(); &#125; @OnMessage public void getMessage(String message) &#123; System.out.println(&quot;收到消息:&quot; + message); &#125;&#125; web页面直接创建webSocket对象。 12345678// 创建连接let socket = new WebSocket(&#x27;ws://localhost:9863/msgChannel&#x27;)// 发送消息socket.send(msg)// 监听消息socket.onmessage = (event) =&gt; &#123; console.log(&#x27;Message from server &#x27;, event.data);&#125;; 客户端【Web】1234// 创建连接let socket = new WebSocket(&#x27;ws://localhost:9863/msgChannel&#x27;)// 发送消息socket.send(msg) 重点API构造方法1let aWebSocket = new WebSocket(url [, protocols]); 参数 url 要连接的 URL；这应该是 WebSocket 服务器响应的 URL。 protocols 可选 一个协议字符串或者一个包含协议字符串的数组。这些字符串用于指定子协议，这样单个服务器可以实现多个 WebSocket 子协议（例如，您可能希望一台服务器能够根据指定的协议（protocol）处理不同类型的交互）。如果不指定协议字符串，则假定为空字符串。 实例方法 close()参数 code 可选 一个数字状态码，它解释了连接关闭的原因。如果没有传这个参数，默认使用 1005。CloseEvent的允许的状态码见状态码列表 。 reason 可选 一个人类可读的字符串，它解释了连接关闭的原因。这个 UTF-8 编码的字符串不能超过 123 个字节。 实例方法 send()参数 data 用于传输至服务器的数据。 data必须是以下类型之一： USVString文本字符串【常用】 ArrayBuffer有类型的数组对象 Blob二进制blob数据【常用】 事件 closeWebSocket.onclose 属性返回一个事件监听器，这个事件监听器将在 WebSocket 连接的readyState变为 CLOSED时被调用，它接收一个名字为“close”的 CloseEvent事件。 123WebSocket.onclose = function(event) &#123; console.log(&quot;WebSocket已关闭&quot;);&#125;; 事件 error当websocket的连接由于一些错误事件的发生 (例如无法发送一些数据) 而被关闭时，一个error事件将被触发。 1234const socket = new WebSocket(&#x27;ws://localhost:8080&#x27;);socket.addEventListener(&#x27;error&#x27;, function (event) &#123; console.log(&#x27;WebSocket error: &#x27;, event);&#125;); 事件 messagemessage 事件会在 WebSocket 接收到新消息时被触发。 123456// 创建一个 WebSocket 连接const socket = new WebSocket(&#x27;ws://localhost:8080&#x27;);// 监听消息socket.onmessage = (event) =&gt; &#123; console.log(&#x27;Message from server &#x27;, event.data);&#125;; 事件 open**WebSocket.onopen**属性定义一个事件处理程序，当WebSocket的连接状态readyState变为1时调用;这意味着当前连接已经准备好发送和接受数据。 12345const socket = new WebSocket(&#x27;ws://localhost:8080&#x27;);// 也就是说当服务端也同意建立连接后，该事件就会触发socket.onopen = function(event) &#123; console.log(&quot;WebSocket is open now.&quot;);&#125;; 服务端【java】javax提供了websocket的功能实现。可以直接使用注解的方式进行开发。 重点注解 @OnOpen有连接时的触发函数。 我们可以在用户连接时记录用户的连接带的参数，只需在参数列表中增加参数：@PathParam(“paraName”) String paraName。 @OnMessage收到消息时调用的函数，其中Session是每个websocket特有的数据成员 @OnClose连接关闭时的调用方法。 @OnError发生意外错误时调用的函数。 @ServerEndpoint进行声明接口：@ServerEndpoint(value&#x3D;”&#x2F;websocket&#x2F;{paraName}”) 重点对象和方法Session每个Session代表了两个websocket断点的会话；当websocket握手成功后，websocket就会提供一个打开的Session，可以通过这个Session来对另一个端点发送数据；如果Session关闭后发送数据将会报错。 Session.getBasicRemote().sendText(“message”)向该Session连接的用户发送字符串数据。 Session.getAsyncRemote().sendText(“message”)异步非阻塞向该Session连接的用户发送字符串数据。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import com.xiaoyi.websocketchat.handler.WebSocketMassageHandler;import com.xiaoyi.websocketchat.handlerMapping.MessageHandlerMapping;import org.springframework.stereotype.Component;import javax.websocket.*;import javax.websocket.server.PathParam;import javax.websocket.server.ServerEndpoint;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * @author 小易 * @version 1.0 * @description TODO webSocket服务 * @date 2022/12/9 9:07 */@ServerEndpoint(&quot;/msgChannel/&#123;id&#125;&quot;)@Componentpublic class WebSocketServer &#123; /** 会话集合 */ private static final Map&lt;String, WebSocketServer&gt; sessionMap = new ConcurrentHashMap&lt;&gt;(); /** 与某个客户端的连接会话，需要通过它来给客户端发送数据 */ private Session session; /** 接收id */ private String id = &quot;&quot;; @OnOpen public void open(@PathParam(&quot;id&quot;)String id, Session session)&#123; this.session = session; this.id = id; sessionMap.put(id, this); System.out.println(&quot;与[&quot;+id+&quot;]建立连接&quot;); &#125; @OnClose public void close() &#123; // 添加关闭会话时的操作 sessionMap.remove(this.id); System.out.println(&quot;与[&quot;+id+&quot;]断开连接&quot;); &#125; @OnError public void error(Throwable t) &#123; // 添加处理错误的操作 System.out.println(&quot;发生错误&quot;); t.printStackTrace(); &#125; @OnMessage public void getMessage(String message) &#123; // 接收到消息后通过处理器适配器获取对应的消息处理器 WebSocketMassageHandler handler = MessageHandlerMapping.getWebSocketMessageHandler(message); // 使用消息处理器处理消息 handler.handler(message, this); &#125; public synchronized void sendMessage(String message) &#123; this.session.getAsyncRemote().sendText(message);//非阻塞式的 &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"WebSocket","slug":"前端/WebSocket","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/WebSocket/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"http://example.com/tags/websocket/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"}],"author":["extends"]},{"title":"Axios跨域","slug":"Axios跨域","date":"2022-11-17T07:35:59.000Z","updated":"2023-01-03T09:31:42.000Z","comments":true,"path":"2022/11/17/Axios跨域/","link":"","permalink":"http://example.com/2022/11/17/Axios%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"1报错信息: Access to XMLHttpRequest at &#x27;http://localhost:8888/cert/certCompany/list2&#x27; from origin &#x27;http://localhost:8889&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. 解决方案 main.js 引入axios 1234//引入axios by zhengkai.blog.csdn.netimport axios from &#x27;axios&#x27;Vue.prototype.$axios = axiosaxios.defaults.baseURL = &#x27;/api&#x27; //自动附加在所有axios请求前面，则可以省略/api，直接写&#x27;/xxxx/xxx&#x27;。否则需要设置&#x27;/api/xxxx/xxx&#x27; config.index.js 改造proxyTable部分，引入虚拟代理 ，请求target这个地址的时候直接写成/api即可。 1234567891011121314151617181920212223dev: &#123; env: require(&#x27;./dev.env&#x27;), port: 8889, autoOpenBrowser: true, assetsSubDirectory: &#x27;static&#x27;, assetsPublicPath: &#x27;/&#x27;, proxyTable: &#123; //axios跨域改造 by zhengkai.blog.csdn.net &#x27;/api&#x27;: &#123; target:&#x27;http://localhost:8888/cert/&#x27;, // 你请求的第三方接口 changeOrigin:true, // 在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题 pathRewrite:&#123; // 路径重写， &#x27;^/api&#x27;: &#x27;&#x27; // 替换target中的请求地址，也就是说/api=/target，请求target这个地址的时候直接写成/api即可。 &#125; &#125; &#125;, // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot; // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. cssSourceMap: false &#125; 业务.vue 1234567axios.post(&#x27;/certCompany/list2&#x27;,JSON.stringify(this.searchParam)) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"前端/axios","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/axios/"}],"tags":[{"name":"axios","slug":"axios","permalink":"http://example.com/tags/axios/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}],"author":["extends"]},{"title":"vue中画面样式闪烁","slug":"vue中画面样式闪烁","date":"2022-11-17T07:32:07.000Z","updated":"2023-01-03T09:31:50.000Z","comments":true,"path":"2022/11/17/vue中画面样式闪烁/","link":"","permalink":"http://example.com/2022/11/17/vue%E4%B8%AD%E7%94%BB%E9%9D%A2%E6%A0%B7%E5%BC%8F%E9%97%AA%E7%83%81/","excerpt":"","text":"小型项目中使用 v-cloak 指令是解决屏幕闪动，在大型、工程化的项目中（webpack、vue-router）只有一个空的 div 元素，元素中的内容是通过路由挂载来实现的，这时我们就不需要用到 v-cloak 指令了。 v-cloak: ​ 可以使用 v-cloak 指令设置样式，这些样式会在 Vue 实例编译结束时，从绑定的 HTML 元素上被移除。 123&lt;div id=&quot;app&quot; v-cloak&gt; &#123;&#123;context&#125;&#125;&lt;/div&gt; 123[v-cloak]&#123; display: none;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"屏幕闪动","slug":"屏幕闪动","permalink":"http://example.com/tags/%E5%B1%8F%E5%B9%95%E9%97%AA%E5%8A%A8/"}],"author":["extends"]}],"categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"前后端","slug":"前后端","permalink":"http://example.com/categories/%E5%89%8D%E5%90%8E%E7%AB%AF/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"前端/axios","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/axios/"},{"name":"服务器","slug":"后端/服务器","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"WebSocket","slug":"前端/WebSocket","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/WebSocket/"},{"name":"vue","slug":"前端/vue","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"mybatis","slug":"mybatis","permalink":"http://example.com/tags/mybatis/"},{"name":"springboot","slug":"springboot","permalink":"http://example.com/tags/springboot/"},{"name":"swagger","slug":"swagger","permalink":"http://example.com/tags/swagger/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF/"},{"name":"axios","slug":"axios","permalink":"http://example.com/tags/axios/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"websocket","slug":"websocket","permalink":"http://example.com/tags/websocket/"},{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"},{"name":"屏幕闪动","slug":"屏幕闪动","permalink":"http://example.com/tags/%E5%B1%8F%E5%B9%95%E9%97%AA%E5%8A%A8/"}]}