{"meta":{"title":"extends","subtitle":"","description":"个人博客","author":"extends","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-03-02T02:02:20.971Z","updated":"2022-11-17T07:26:24.000Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2023-03-02T02:02:20.974Z","updated":"2022-11-17T07:26:32.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-03-02T02:02:20.977Z","updated":"2022-11-17T07:27:22.000Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-03-02T02:02:20.978Z","updated":"2022-11-17T07:26:47.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"零拷贝","slug":"零拷贝","date":"2025-02-12T05:56:21.000Z","updated":"2025-02-12T05:58:37.639Z","comments":true,"path":"2025/02/12/零拷贝/","link":"","permalink":"http://example.com/2025/02/12/%E9%9B%B6%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"JAVA 零拷贝Java 零拷贝（Zero-Copy）是一种用于提高 I&#x2F;O 性能的技术，它允许在进行文件传输时减少数据在内存中的复制次数，进而提高效率。Java 中的零拷贝通常用于网络编程和文件操作，主要依赖于操作系统提供的底层机制，如 Linux 的 sendfile()、mmap() 等。 传统IO拷贝文件操作 用户空间：创建输入流，开始读取文件 用户态切换到内核态【状态切换】 内核空间：CPU检查内核缓冲区里是否有指定的数据，直接就可以读。如果没有，CPU就交给DMA，DMA负责把硬盘读到缓冲区，然后告诉CPU移动完了，然后把阻塞的进程再移动到运行队列 内核空间：CPU将该文件从内核缓冲区复制到用户空间的缓冲区【CPU复制】 内核态切换到用户态【状态切换】 用户空间：创建输出流，开始写文件 用户态切换到内核态【状态切换】 内核空间：CPU将该文件从用户空间的缓冲区复制到socket缓冲区【CPU复制】 内核空间：CPU交给DMA将文件从socket缓冲区写到指定位置 内核态切换到用户态【状态切换】 复制了4次，进程切换了4次 12345678910Note right of 用户态: 开始读入用户态 --&gt; 内核态:状态切换硬盘 -&gt; 内核态:DMA拷贝内核态 -&gt; 用户态:CPU拷贝内核态 --&gt; 用户态:状态切换Note right of 用户态: 开始写出用户态 --&gt; 内核态:状态切换用户态 -&gt; 内核态:CPU拷贝到socket缓冲区内核态 --&gt; 用户态:状态切换内核态 -&gt; 网卡:DMA拷贝 零拷贝操作流程MMAP： DMA把磁盘上的文件映射到内存，用户空间和内核空间共享同一块物理地址，这样就无需进程用户空间和内核空间的来回复制。写到网卡的时候，共享空间的内容拷贝到socket缓冲区（CPU复制），然后告诉DMA发送到网卡。3次复制（2次DMA，一次CPU复制） **调用 mmap()**：应用程序调用 mmap() 系统调用，将文件的一部分或全部映射到其虚拟地址空间。此时，内核并没有实际加载文件数据，只是建立了文件与进程虚拟内存之间的映射关系。 访问文件内容： 当应用程序第一次访问映射的内存区域时，会触发页面缺失（page fault）。内核检测到访问的是映射的文件区域，因此会将文件对应部分的数据从磁盘加载到内核的页缓存中。 从磁盘到内核页缓存：此时，数据从磁盘读取并存储在内核的页缓存中，但没有额外的数据复制操作。 直接在内存中操作数据：映射的文件内容与进程的虚拟地址空间一一对应，应用程序通过读写内存的方式直接操作文件内容，省去了从内核空间到用户空间的额外数据拷贝步骤。 同步操作： 如果是读操作，内核直接从页缓存中返回数据，无需进行额外的拷贝。 如果是写操作，内核会将应用程序对映射内存的修改标记为“脏页”（dirty page），并在适当的时候将这些脏页同步回磁盘（例如通过 msync() 调用或在 munmap() 时）。 12345678用户态 --&gt; 内核态:状态切换硬盘 -&gt; 内核态:DMA拷贝内核态 --&gt; 用户态:状态切换Note right of 用户态: 共享缓冲区用户态 --&gt; 内核态:状态切换内核态 -&gt;&gt; 内核态:CPU拷贝到socket缓冲区内核态 --&gt; 用户态:状态切换内核态 -&gt; 网卡:DMA拷贝 sendfile： 打开文件的fd+socket的fd告诉sendfile，也是经过和上面一样的3次复制。不过只进程了2次用户态和内核态的切换 12345用户态 --&gt; 内核态:状态切换硬盘 -&gt; 内核态:DMA拷贝内核态 -&gt; 内核态:CPU拷贝到socket缓冲区内核态 --&gt; 用户态:状态切换内核态 -&gt; 网卡:DMA拷贝 NIObuffer数组，NIO把byte数组的位置和长度发给内核态，内核空间可以访问用户空间，这叫跨传输。如果发送GC，stw，线程都停止，会回收垃圾对象，会进行碎片整理，所以位置会变。NIO选择在堆外创建一个同样大小的buffer，先从用户空间拷贝到堆外空间（cpu拷贝），再发送write系统调用，这时候发送堆外的位置+长度，堆外是不发生GC的，然后再拷贝到内核缓冲区。NIO合理使用堆外内存可以避免堆内到堆外的一次拷贝，可以直接放到堆外buffer。 NIO必然使用了堆外空间：在NIO中使用了IOUtil.write()，会判断是否是堆外内存if(var instanceof DirectBuffer)&#123;return writeFromNativeBuffer();&#125;，否则是堆内，Util.getTemporaryDirectorBuffer()，创建临时堆外空间，大小和当前堆内buffer大小一样大，然后从堆内buffer拷贝到堆外 buffer ： var堆外.put(var堆内)，然后writeFromNativeBuffer()，从堆外写到内核缓冲区。 如何释放堆外空间： 合理使用堆外内存可以减少拷贝。但是堆外不受JVM管理，如何释放？JVM中根据可达性算法从根对象跟踪引用对象。JVM的栈里指向了一个堆内的对象，该堆内对象指向堆外内存，该堆内对象代理操作堆外内存。如果不可达了后，判断该代理对象成为垃圾，回收的时候会去释放堆外空间。 DirectByteBuffer.java： 构造函数中用unsafe.allocate(size)分配堆外内存，返回堆外地址base。unsafe.setMemory(base,size,0)将该堆外空间初始化置位0。然后创建Cleaner对象Cleaner.create(this堆外内存引用,new Deallocator(base,size,cap))负责清理堆外内存。里面传了个Deallocator释放器，他的run()里有unsafe.freeMemeory(address)。 Cleaner继承了PhantomReference虚引用。 利用虚引用，上面有一个c.clean()负责释放堆外空间（里面有deallocate释放器），不会执行refQueue入队操作，所以在cleaner里引用队列没有用，但是因为虚引用必须传引用队列，所以new了个static引用队列占坑。 然后NIO的channel与堆外buffer打交道，堆外buffer与内核缓冲区打交道。堆外是为了传buffer位置的时候不受GC垃圾整理影响。 DMA1 要把内存数据发送到网卡然后发出去时： 没有DMA时候怎么办： CPU读内存数据到CPU的高速缓存，再写到网卡。这样就把CPU的速度拉低到和网卡一个速度。 有了DMA： 把内存数据读到socket内核缓存区（CPU复制），CPU就不管了，告诉DMA开始接管。DMA开始把内核缓冲区的数据写到网卡。DMA读socket缓冲区，读到DMA缓冲区，然后写到网卡中。不停写到网卡。 DMA发送完后，DMA中断CPU，（这样CPU就知道socket内核缓冲区又空出来了），CPU从用户态切换到内核态，执行中断处理程序，将socket缓冲区阻塞的进程移回到运行队列。 比如要发送的数据是100k，但是内核缓冲区就50k，这样第二次50k也能发出去了。 2 读硬件时： CPU检查内核缓冲区里是否有指定的数据，直接就可以读。如果没有，CPU就交给DMA，DMA负责把硬盘读到缓冲区，然后告诉CPU移动完了，然后把阻塞的进程再移动到运行队列。 状态切换 用户空间：用户代码、用户堆栈 内核空间：内核代码、内核调度程序、进程描述符（内核堆栈、thread_info进程描述符） 进程描述符和用户的进程是一一对应的 SYS_API：系统调用，如read、write 进程描述符：进程从用户态切换到内核态时，需要保存用户态时的上下文信息，比如：用户程序基地址，程序计数器、cpu cache、寄存器。。。方便程序从内核态切换回用户态时恢复现场。 内核堆栈：系统调用函数也是要创建变量的，这些变量在内核堆栈上分配 系统调用比如用户想要读取硬盘上的文件，发起read调用，这个read只是内核态的库函数api，该库函数会发起系统调用。该库函数里面有80中断，软中断，进程切换到内核态。到cpu里存一个系统调用号（表示哪个系统函数，比如read）。把cpu的临时数据都保存到thread_info中（恢复到用户态时用），然后执行80中断处理程序，找到刚刚存的系统调用号（比如read），先检查缓存中有没有对应的数据，没有就去磁盘中加载到内核缓冲区，然后从内核缓冲区拷贝到用户空间，然后恢复到用户态，恢复现场，用户态就知道从哪继续执行。 缓冲区读写 读：用户态切换到内核态，先看内核态缓冲区有没有，有就直接读到，没有就交给DMA去读。DMA控制器从磁盘、网卡、其他IO设备中读。CPU在这个期间可以执行其他进程。DMA加载到内核缓冲区后告诉CPU，CPU把数据拷贝到用户态，CPU把该进程从阻塞队列移到到运行队列。 写：缓存区满了之后，写操作阻塞，缓冲区有一个等待队列，记录阻塞的进程（java的轻量级进程），DMA把缓冲区数据写到网卡后告诉CPU，中断CPU，把该进程移动到运行队列。 虚拟内存物理内存：类似于大的数组，可以随机读取。 以前单核计算机时只需要保证保证不写内核空间即可。多核计算机引入多进程后，每个进程有自己的用户空间，得防止不能访问其他进程空间。所以引入了虚拟内存。进程分配了虚拟内存，CPU MMU单元可以帮助完成虚拟内存到物理内存的映射。虚拟内存可以大于真实物理内存，MMU可以把不常用的东西从物理内存放到磁盘上（swap区）。因为可以替换，所以不同进程的虚拟内存空间的地址可以映射到用一个物理内存。利用这个特性，可以把用户空间和内核空间的地址翻译为同一块物理内存地址，就可以减少拷贝，即零拷贝的技术。 引用引用有：强、软、虚、弱四种引用。 栈里存的是栈帧（即方法），有的强引用直接指向obj，也有的强引用指向ref，ref实例存放到堆，ref再指向obj。这个ref指的是除了强引用外的引用，不是我们写的a &#x3D; new A(),b&#x3D;a;这还是强引用 Soft软引用情况下，强引用置位null时，gc时可能就释放了obj。 软引用不一定被回收 - Weak弱引用情况下，强引用置为null时，gc一定回收obj buffer = new buffer()，然后weakRef = new WeakReference(buffer,refQueue)，然后buffer=null失去强引用，只剩下了一个弱引用，GC之前weakReference.get()可以拿到obj对象引用，GC之后weakReference.get()为null。但是GC之前引用队列refQueue里refQueue.poll()为null，GC之后refQueue中获取的ref &#x3D; refQueue.poll()和weakRef一致，即被回收以后就把weakRef加入到refQueue，所以GC之后的refQueue.poll()==weakRef。也就是说这个引用队列知道谁被回收了，weakHashmap就是利用这种方式清空无效的kv对 Phantom虚引用情况下，通过虚引用get永远是null，当强引用变为null时，gc一定回收obj。虚引用的作用是创建虚引用时，可以传给一个引用对象，当obj被GC时，就可以在引用队列里找到虚引用 构造方法必须传引用队列RefQueue GC之前引用队列里为null，get也返回null。GC之后refQueue.poll()有了虚引用，get还是null。源码中get都返回null：PhantomRef.get()&#123;return null;&#125; 所以说Ref所指向的对象再GC时，根可达性算法不管他，obj还是会被回收 Reference： 四种状态： Active：激活。创建ref对象时就是激活状态 Pending：等待入队。所对应的强引用被GC，就要入队，是GC线程做的 Enqueued：入队了。守护线程， - 如果指定了refQueue消费pending移动到enqueued状态。refQueue.poll时进入失效状态 - 如果没有指定refQueue，直接到失效状态。 Inactive：失效 12345678910111213141516171819202122232425262728293031java public class Reference&#123; ref属性：保存真实对象引用。 queue属性：指定引用队列（虚引用必须指定） next属性：指向下一个ref，单向链表 discovered属性：VM线程使用。来判定当前ref的真实对象是垃圾后，会将当前ref加入到pending队列，然后JM把discovered连接起来组成pending链表 static pending属性：是一个ref链表。所以说多个堆内对象的ref就可以组合到pending中。GC线程操作的 static&#123; handler = new ReferenceHandler(); handler.setDaemon(true); handler.start(); &#125;&#125;private class ReferenceHandler extends Thread&#123; public void run() &#123; if(pending!=null)&#123; pending先进后出; 判断当前元素是不是Cleaner，继承了虚引用; pending出队; &#125; else &#123; 阻塞等待gc线程唤醒，gc向pending队列添加新ref之后会notify &#125; if(Cleaner类型) &#123; c.clean(); return; &#125; else &#123; 获取创建ref时指定的refQueue，如果指定了就入队; return; &#125; tryHandlePending(true); &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80/"}],"author":["extends"]},{"title":"springboot配置拦截器拼接SQL","slug":"springboot配置拦截器拼接SQL","date":"2024-04-27T03:14:41.000Z","updated":"2024-04-27T03:16:08.411Z","comments":true,"path":"2024/04/27/springboot配置拦截器拼接SQL/","link":"","permalink":"http://example.com/2024/04/27/springboot%E9%85%8D%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8%E6%8B%BC%E6%8E%A5SQL/","excerpt":"","text":"SpringBoot自动装配SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的META-INF&#x2F;spring.factories文件，将文件中配置的类型信息加载到 Spring 容器，并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。 web线程内的拦截线程内可以使用ThreadLocal对象进行线程间的数据隔离 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package cn.iocoder.yudao.framework.app.core.context;import com.alibaba.ttl.TransmittableThreadLocal;/** * 多租户上下文 Holder * * @author 芋道源码 */public class AppContextHolder &#123; /** * 当前应用编号 */ private static final ThreadLocal&lt;Long&gt; APP_ID = new TransmittableThreadLocal&lt;&gt;(); /** * 是否忽略租户 */ private static final ThreadLocal&lt;Boolean&gt; IGNORE = new TransmittableThreadLocal&lt;&gt;(); /** * 获得租户编号。 * * @return 租户编号 */ public static Long getAppId() &#123; return APP_ID.get(); &#125; /** * 获得应用编号。如果不存在，则抛出 NullPointerException 异常 * * @return 租户编号 */ public static Long getRequiredAppId() &#123; Long appId = getAppId(); if (appId == null) &#123; throw new NullPointerException(&quot;AppContextHolder 不存在应用编号！&quot;); &#125; return appId; &#125; public static void setAppId(Long tenantId) &#123; APP_ID.set(tenantId); &#125; public static void setIgnore(Boolean ignore) &#123; IGNORE.set(ignore); &#125; /** * 当前是否忽略租户 * * @return 是否忽略 */ public static boolean isIgnore() &#123; return Boolean.TRUE.equals(IGNORE.get()); &#125; public static void clear() &#123; APP_ID.remove(); IGNORE.remove(); &#125;&#125; 配置全局的过滤器过滤请求，将需要的参数取出并存入上面配置的ThreadLocal中 1234567891011121314151617181920212223import org.springframework.web.filter.OncePerRequestFilter;/** * 多应用 Context Web 过滤器 * 将请求 Header 中的 app-id 解析出来，添加到 &#123;@link AppContextHolder&#125; 中，这样后续的 DB 等操作，可以获得到应用编号。 */public class AppContextWebFilter extends OncePerRequestFilter &#123; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123; // 使用工具类从request中取出需要的参数进行保存 Long appId = WebFrameworkUtils.getAppId(request); if (appId != null) &#123; AppContextHolder.setAppId(appId); &#125; try &#123; chain.doFilter(request, response); &#125; finally &#123; // 清理 AppContextHolder.clear(); &#125; &#125;&#125; SQL拦截拼接条件利用mybatisplus的租户插件进行拦截添加 AppHandler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package cn.iocoder.yudao.framework.app.core.plugins;import net.sf.jsqlparser.expression.Expression;import net.sf.jsqlparser.schema.Column;import java.util.List;public interface AppHandler &#123; /** * 获取应用 ID 值表达式，只支持单个 ID 值 * &lt;p&gt; * * @return 应用 ID 值表达式 */ Expression getAppId(); /** * 获取应用字段名 * &lt;p&gt; * 默认字段名叫: app_id * * @return 应用字段名 */ default String getAppIdColumn() &#123; return &quot;app_id&quot;; &#125; /** * 根据表名判断是否忽略拼接多应用条件 * &lt;p&gt; * 默认都要进行解析并拼接多应用条件 * * @param tableName 表名 * @return 是否忽略, true:表示忽略，false:需要解析并拼接多应用条件 */ default boolean ignoreTable(String tableName) &#123; return false; &#125; /** * 忽略插入应用字段逻辑 * * @param columns 插入字段 * @param appIdColumn 应用 ID 字段 * @return */ default boolean ignoreInsert(List&lt;Column&gt; columns, String appIdColumn) &#123; return columns.stream().map(Column::getColumnName).anyMatch(i -&gt; i.equalsIgnoreCase(appIdColumn)); &#125;&#125; AppInnerInterceptor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214package cn.iocoder.yudao.framework.app.core.plugins;import com.baomidou.mybatisplus.core.plugins.InterceptorIgnoreHelper;import com.baomidou.mybatisplus.core.toolkit.CollectionUtils;import com.baomidou.mybatisplus.core.toolkit.ExceptionUtils;import com.baomidou.mybatisplus.core.toolkit.PluginUtils;import com.baomidou.mybatisplus.core.toolkit.StringPool;import com.baomidou.mybatisplus.extension.plugins.inner.BaseMultiTableInnerInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.InnerInterceptor;import lombok.*;import net.sf.jsqlparser.expression.Expression;import net.sf.jsqlparser.expression.StringValue;import net.sf.jsqlparser.expression.operators.relational.EqualsTo;import net.sf.jsqlparser.expression.operators.relational.ExpressionList;import net.sf.jsqlparser.expression.operators.relational.ItemsList;import net.sf.jsqlparser.expression.operators.relational.MultiExpressionList;import net.sf.jsqlparser.schema.Column;import net.sf.jsqlparser.schema.Table;import net.sf.jsqlparser.statement.delete.Delete;import net.sf.jsqlparser.statement.insert.Insert;import net.sf.jsqlparser.statement.select.*;import net.sf.jsqlparser.statement.update.Update;import org.apache.ibatis.executor.Executor;import org.apache.ibatis.executor.statement.StatementHandler;import org.apache.ibatis.mapping.BoundSql;import org.apache.ibatis.mapping.MappedStatement;import org.apache.ibatis.mapping.SqlCommandType;import org.apache.ibatis.session.ResultHandler;import org.apache.ibatis.session.RowBounds;import java.sql.Connection;import java.sql.SQLException;import java.util.List;@Data@NoArgsConstructor@AllArgsConstructor@ToString(callSuper = true)@EqualsAndHashCode(callSuper = true)public class AppInnerInterceptor extends BaseMultiTableInnerInterceptor implements InnerInterceptor &#123; private AppHandler appHandler; @Override public void beforeQuery(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123; // 排除不需要添加的 if (InterceptorIgnoreHelper.willIgnoreTenantLine(ms.getId())) &#123; return; &#125; // 调用执行 PluginUtils.MPBoundSql mpBs = PluginUtils.mpBoundSql(boundSql); // 将sql替换 mpBs.sql(parserSingle(mpBs.sql(), null)); &#125; @Override public void beforePrepare(StatementHandler sh, Connection connection, Integer transactionTimeout) &#123; PluginUtils.MPStatementHandler mpSh = PluginUtils.mpStatementHandler(sh); MappedStatement ms = mpSh.mappedStatement(); SqlCommandType sct = ms.getSqlCommandType(); if (sct == SqlCommandType.INSERT || sct == SqlCommandType.UPDATE || sct == SqlCommandType.DELETE) &#123; // 排除不需要添加的 if (InterceptorIgnoreHelper.willIgnoreTenantLine(ms.getId())) &#123; return; &#125; PluginUtils.MPBoundSql mpBs = mpSh.mPBoundSql(); mpBs.sql(parserMulti(mpBs.sql(), null)); &#125; &#125; @Override protected void processSelect(Select select, int index, String sql, Object obj) &#123; final String whereSegment = (String) obj; processSelectBody(select.getSelectBody(), whereSegment); List&lt;WithItem&gt; withItemsList = select.getWithItemsList(); if (!CollectionUtils.isEmpty(withItemsList)) &#123; withItemsList.forEach(withItem -&gt; processSelectBody(withItem, whereSegment)); &#125; &#125; @Override protected void processInsert(Insert insert, int index, String sql, Object obj) &#123; if (appHandler.ignoreTable(insert.getTable().getName())) &#123; // 过滤退出执行 return; &#125; List&lt;Column&gt; columns = insert.getColumns(); if (CollectionUtils.isEmpty(columns)) &#123; // 针对不给列名的insert 不处理 return; &#125; String appIdColumn = appHandler.getAppIdColumn(); if (appHandler.ignoreInsert(columns, appIdColumn)) &#123; // 针对已给出租户列的insert 不处理 return; &#125; columns.add(new Column(appIdColumn)); // fixed gitee pulls/141 duplicate update List&lt;Expression&gt; duplicateUpdateColumns = insert.getDuplicateUpdateExpressionList(); if (CollectionUtils.isNotEmpty(duplicateUpdateColumns)) &#123; EqualsTo equalsTo = new EqualsTo(); equalsTo.setLeftExpression(new StringValue(appIdColumn)); equalsTo.setRightExpression(appHandler.getAppId()); duplicateUpdateColumns.add(equalsTo); &#125; Select select = insert.getSelect(); if (select != null) &#123; this.processInsertSelect(select.getSelectBody(), (String) obj); &#125; else if (insert.getItemsList() != null) &#123; // fixed github pull/295 ItemsList itemsList = insert.getItemsList(); Expression appId = appHandler.getAppId(); if (itemsList instanceof MultiExpressionList) &#123; ((MultiExpressionList) itemsList).getExpressionLists().forEach(el -&gt; el.getExpressions().add(appId)); &#125; else &#123; ((ExpressionList) itemsList).getExpressions().add(appId); &#125; &#125; else &#123; throw ExceptionUtils.mpe(&quot;Failed to process multiple-table update, please exclude the tableName or statementId&quot;); &#125; &#125; /** * update 语句处理 */ @Override protected void processUpdate(Update update, int index, String sql, Object obj) &#123; final Table table = update.getTable(); if (appHandler.ignoreTable(table.getName())) &#123; // 过滤退出执行 return; &#125; update.setWhere(this.andExpression(table, update.getWhere(), (String) obj)); &#125; /** * delete 语句处理 */ @Override protected void processDelete(Delete delete, int index, String sql, Object obj) &#123; if (appHandler.ignoreTable(delete.getTable().getName())) &#123; // 过滤退出执行 return; &#125; delete.setWhere(this.andExpression(delete.getTable(), delete.getWhere(), (String) obj)); &#125; /** * 处理 insert into select * &lt;p&gt; * 进入这里表示需要 insert 的表启用了多租户,则 select 的表都启动了 * * @param selectBody SelectBody */ protected void processInsertSelect(SelectBody selectBody, final String whereSegment) &#123; PlainSelect plainSelect = (PlainSelect) selectBody; FromItem fromItem = plainSelect.getFromItem(); if (fromItem instanceof Table) &#123; // fixed gitee pulls/141 duplicate update processPlainSelect(plainSelect, whereSegment); appendSelectItem(plainSelect.getSelectItems()); &#125; else if (fromItem instanceof SubSelect) &#123; SubSelect subSelect = (SubSelect) fromItem; appendSelectItem(plainSelect.getSelectItems()); processInsertSelect(subSelect.getSelectBody(), whereSegment); &#125; &#125; /** * 追加 SelectItem * * @param selectItems SelectItem */ protected void appendSelectItem(List&lt;SelectItem&gt; selectItems) &#123; if (CollectionUtils.isEmpty(selectItems)) &#123; return; &#125; if (selectItems.size() == 1) &#123; SelectItem item = selectItems.get(0); if (item instanceof AllColumns || item instanceof AllTableColumns) &#123; return; &#125; &#125; selectItems.add(new SelectExpressionItem(new Column(appHandler.getAppIdColumn()))); &#125; /** * 应用字段别名设置 * @param table 表对象 * @return 字段 */ protected Column getAliasColumn(Table table) &#123; StringBuilder column = new StringBuilder(); // 禁止 `为了兼容隐式内连接，没有别名时条件就需要加上表名` // 该起别名就要起别名 if (table.getAlias() != null) &#123; column.append(table.getAlias().getName()); &#125; else &#123; column.append(table.getName()); &#125; column.append(StringPool.DOT).append(appHandler.getAppIdColumn()); return new Column(column.toString()); &#125; @Override public Expression buildTableExpression(Table table, Expression where, String whereSegment) &#123; if (appHandler.ignoreTable(table.getName())) &#123; return null; &#125; return new EqualsTo(getAliasColumn(table), appHandler.getAppId()); &#125;&#125; 在springboot配置类中将拦截器添加进去 123456789@Beanpublic AppInnerInterceptor AppDatabaseInterceptor(AppProperties properties, MybatisPlusInterceptor interceptor) &#123; AppInnerInterceptor inner = new AppInnerInterceptor(new AppHandlerImpl(properties)); // 添加到 interceptor 中 // 需要加在首个，主要是为了在分页插件前面。这个是 MyBatis Plus 的规定 MyBatisUtils.addInterceptor(interceptor, inner, 1); return inner;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://example.com/tags/springboot/"}],"author":["extends"]},{"title":"JDBC流式查询数据问题","slug":"JDBC流式查询数据问题","date":"2024-04-27T03:09:12.000Z","updated":"2024-04-27T03:10:46.584Z","comments":true,"path":"2024/04/27/JDBC流式查询数据问题/","link":"","permalink":"http://example.com/2024/04/27/JDBC%E6%B5%81%E5%BC%8F%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/","excerpt":"","text":"JDBC查询大数据防止内存溢出问题查询数据库中大量数据时发生内存溢出 原因jdbc查询MySQL时会默认一次将查询的结果数据全部从服务器加载到内存中，当数据过多时，就会导致内存溢出。 解决方案 设置每次从服务器加载到内存的条数 statement.setFetchSize(batchSize); 设置ResultSet对象的大小的限制 statement.setMaxRows（int i） 1234// 设置为只能向下读取和只读，能够及时释放内存Statement statement = connection.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);statement.setFetchSize(batchSize); // 设置从数据库取得多行的行数大小statement.setMaxRows(maxRows); // 将此 Statement 对象生成的所有 ResultSet 对象可以包含的最大行数限制设置为给定数 可能会出现的问题123org.springframework.dao.DataAccessResourceFailureException: PreparedStatementCallback; SQL []; Could not create connection to database server. Attempted reconnect 3 times. Giving up.; nested exception is java.sql.SQLNonTransientConnectionException: Could not create connection to database server. Attempted reconnect 3 times. Giving up. ......Caused by: java.sql.SQLException: Streaming result set com.mysql.cj.protocol.a.result.ResultsetRowsStreaming@5869a708 is still active. No statements may be issued when any streaming result sets are open and in use on a given connection. Ensure that you have called .close() on any active streaming result sets before attempting more queries. 无法建立连接服务 以下错误消息 “流式传输结果集 com.mysql.jdbc.RowDataDynamic@XXXXXX 仍然处于活动状态. 当任何流式传输结果集打开并在给定连接上使用时, 不会发出任何语句. 确保您已调用 .close() 在尝试更多查询之前在任何活动的流式传输结果集上” 来自 MySQL. ​ 流模式有一个限制: 当结果集在 MySQL 连接上以流模式打开时, 您不能使用同一数据库连接来运行其他查询. 这正是上面的错误消息所告诉的. 该问题的解决方案是将 MySQL 连接设置更改为使用 CursorFetch 模式而不是 Streaming 模式. ​ 其实 MySQL 本身并没有 FetchSize 方法, 它是通过使用 CS 阻塞方式的网络流控制实现服务端不会一下发送大量数据到客户端撑爆客户端内存, 这样带来的问题: 如果使用了流式查询, 一个 MySQL 数据库连接同一时间只能为一个 ResultSet 对象服务, 并且如果该 ResultSet 对象没有关闭, 势必会影响其他查询对数据库连接的使用! 此为大坑,如果应用对数据库连接的消耗要求严苛, 那么流式查询就不再适合 ​ 基于游标的流来检索一组行. 这可以通过将连接属性 useCursorFetch 设置为 true, 然后调用 setFetchSize(int) 来设置每次要获取的行数: 1234conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost/?useCursorFetch=true&quot;, &quot;user&quot;, &quot;s3cr3t&quot;);stmt = conn.createStatement();stmt.setFetchSize(100);rs = stmt.executeQuery(&quot;SELECT * FROM your_table&quot;);","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"}],"author":["extends"]},{"title":"位运算","slug":"位运算","date":"2023-11-25T07:07:07.000Z","updated":"2023-11-25T07:08:22.194Z","comments":true,"path":"2023/11/25/位运算/","link":"","permalink":"http://example.com/2023/11/25/%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"位运算（&amp;、|、^、~、&gt;&gt;、&lt;&lt;）​ 从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算(+、-、*、&#x2F;)都是叫位运算，即将符号位共同参与运算的运算。 符号 描述 运算规则 &amp; 与 两个位都为1时，结果才为1 | 或 两个位都为0时，结果才为0 ^ 异或 两个位相同为0，相异为1 ~ 取反 0变1，1变0 &lt;&lt; 左移 各二进位全部左移若干位，高位丢弃，低位补0 &gt;&gt; 右移 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80/"}],"author":["extends"]},{"title":"计算机负数表示方法","slug":"计算机负数表示方法","date":"2023-11-25T07:04:39.000Z","updated":"2023-11-25T07:06:54.822Z","comments":true,"path":"2023/11/25/计算机负数表示方法/","link":"","permalink":"http://example.com/2023/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%B4%9F%E6%95%B0%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/","excerpt":"","text":"计算机负数表示方法假设有一个 int 类型的数，值为3，那么，我们知道它在计算机中表示为： 00000000 00000000 00000000 00000011 因为int类型的数占用4字节（32位），所以前面填了一堆0。 在计算机中，负数以其正值的补码形式表达。 什么叫补码呢？这得先从原码，反码说起。 原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。 比如: 00000000 00000000 00000000 00000011 是 3的 原码。 反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。 取反操作指：1变0；0变1 比如：00000000 00000000 00000000 00000011的反码是11111111 11111111 11111111 11111100 补码：反码加1称为补码。 也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。 比如：00000000 00000000 00000000 00000011 的反码是：11111111 11111111 11111111 11111100。 那么，补码为： 11111111 11111111 11111111 11111100 + 1 &#x3D; 11111111 11111111 11111111 11111101 所以，-3 在计算机中表达为：11111111 11111111 11111111 11111101。转换为十六进制：0xFFFFFFFD。 为什么要用2的补码首先，要明确一点。计算机内部用什么方式表示负数，其实是无所谓的。只要能够保持一一对应的关系，就可以用任意方式表示负数。所以，既然可以任意选择，那么理应选择一种最方便的方式。 2的补码就是最方便的方式。它的便利体现在，所有的加法运算可以使用同一种电路完成。 还是以-8作为例子。 假定有两种表示方法。一种是直觉表示法，即10001000；另一种是2的补码表示法，即1 1111000。请问哪一种表示法在加法运算中更方便？ 随便写一个计算式，16 + (-8) &#x3D; ? 1 0001000 取反 1 1110111 加1 +1 &#x3D; 1 1111000 再取反 1 0000111 + 1 &#x3D; 1 0001000 取反不不包括符号位两次取反得到原值 正数的补码是其本身 负数的补码是符号位不变 其他位取反之后加1 连着变换两次相当于没有做任何操作16的二进制表示是 00010000，所以用直觉表示法，加法就要写成： ０００１００００＋１０００１０００－－－－－－－－－ １００１１０００ 可以看到，如果按照正常的加法规则，就会得到10011000的结果，转成十进制就是-24。显然，这是错误的答案。也就是说，在这种情况下，正常的加法规则不适用于正数与负数的加法，因此必须制定两套运算规则，一套用于正数加正数，还有一套用于正数加负数。从电路上说，就是必须为加法运算做两种电路。 现在，再来看2的补码表示法。 ０００１００００＋１１１１１０００－－－－－－－－－１００００１０００ 可以看到，按照正常的加法规则，得到的结果是100001000。注意，这是一个9位的二进制数。我们已经假定这是一台8位机，因此最高的第9位是一个溢出位，会被自动舍去。所以，结果就变成了00001000，转成十进制正好是8，也就是16 + (-8) 的正确答案。这说明了，2的补码表示法可以将加法运算规则，扩展到整个整数集，从而用一套电路就可以实现全部整数的加法。 2的补码的本质及正确性我们要看先一下模的概念 “模”是指一个计量系统的计数范围。如时钟等。计算机也可以看成一个计量机器，它也有一个计量范围，即都存在一个“模”。例如： 时钟的计量范围是0～11，模&#x3D;12。 表示n位的计算机计量范围是0～2^(n)-1，模&#x3D;2^(n)。 “模”实质上是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的余数。任何有模的计量器，均可化减法为加法运算。 例如： 假设当前时针指向10点，而准确时间是6点，调整时间可有以下两种拨法：你可以往回拨4个小时，也可以向前拨8个小时（12-10+6，在钟表系统里模是12） 在以12模的系统中，加8和减4效果是一样的，因此凡是减4运算，都可以用加8来代替。 对“模”而言，8和4互为补数。实际上以12模的系统中，11和1，10和2，9和3，7和5，6和6都有这个特性。共同的特点是两者相加等于模。 对于计算机，其概念和方法完全一样。n位计算机，设n&#x3D;8， 所能表示的最大数是11111111，若再加1称为100000000(9位)，但因只有8位，最高位1自然丢失。又回了00000000，所以8位二进制系统的模为2^8。 在这样的系统中减法问题也可以化成加法问题，只需把减数用相应的补数表示就可以了。 在以12模的系统中，加8和减4效果是一样的，因此凡是减4运算，都可以用加8来代替。","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"计算机原理","slug":"计算机原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"}],"author":["extends"]},{"title":"jenkins配置教程","slug":"jenkins配置教程","date":"2023-04-10T08:56:24.000Z","updated":"2023-04-10T09:00:11.297Z","comments":true,"path":"2023/04/10/jenkins配置教程/","link":"","permalink":"http://example.com/2023/04/10/jenkins%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/","excerpt":"","text":"说明简介 Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 部署环境 jdk环境，Jenkins是java语言开发的，因需要jdk环境。 git&#x2F;svn客户端，因一般代码是放在git&#x2F;svn服务器上的，我们需要拉取代码。 maven客户端，因一般java程序是由maven工程，需要maven打包，当然也有其他打包方式，如：gradle jdk 解压 1$ tar -zxvf jdk-11.0.18_linux-x64_bin.tar.gz 配置环境变量 在文件/etc/profile文件中添加下面的内容 123export JAVA_HOME=/java/jdk8export CLASSPATH=.:$JAVA_HOME/lib/dt.:jar$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin git使用命令安装git 12apt install gityum install git ubuntu系统直接使用apt，其他可以使用yum maven 解压 1$ tar -zxvf apache-maven-3.8.8-bin.tar.gz 配置settings.xml文件 123456789# 添加阿里云镜像&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; Jenkins安装通过docker安装使用的jenkins镜像为jenkins/jenkins:lts，本人安装其他jenkins镜像都会有插件下载不下来的问题。 1$ docker pull jenkins/jenkins:lts 使用命令运行docker容器 12345678docker run -d --name jenkins -p 8080:8080 -p 50000:50000 -v /home/extendy/jenkins-data:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock jenkins/jenkins:lts 等待Jenkins启动后访问8080，会进行项目的基础配置 通过war安装 下载Jenkins.war包 启动Jenkins 直接运行Jenkin的War包： 1nohup java -jar jenkins.war &amp; #后台运行 访问Jenkins 默认端口号为8080，在浏览器输入ip地址+8080端口即可 &#x3D;&#x3D;特别注意：通过war包的方式安装Jenkins，Jenkins的workspace文件夹和其他文件都是在下面的目录下&#x3D;&#x3D; 1/root/.jenkins/ 通过命令进行安装通过命令进行安装会因为SSL证书的问题导致无法安装插件的问题，不推荐 配置解锁jenkins密码进入容器 1$ docker exec -u 0 -it jenkins /bin/bash 查看密码 1$ cat /var/jenkins_home/secrets/initialAdminPassword 解锁后安装推荐的插件之后就可以使用了 部署Maven项目使用gitee项目 下载Gitee和Maven插件登陆Jenkins系统管理 &#x3D;&gt;插件管理 下载Maven Integration plugin和Gitee plugin 全局工具配置系统管理&#x3D;&gt;全局工具配置 配置maven、JDK、git 对应系统安装的路径即可 系统配置系统管理&#x3D;&gt;系统配置&#x3D;&gt;Gitee配置 填入自己在gitee中的仓库地址、gitee的域名和令牌 首次需要点击添加添加一个令牌 令牌使用的是gitee令牌，需要在gitee中生成后复制过来。 项目配置 Gitee链接 选择系统配置中填写的选项 JDK 选择配置好的JDK 源码管理 配置源码仓库地址和选择分支（默认为master分支） 构建触发器 构建环境 前置步骤（Pre Steps） Build 使用Maven来构建项目,命令如下： 1clean install -Dmaven.test.skip=true Post Steps 选择仅在生成成功时运行 添加 执行shell 12345cd /usr/local/javaProject/ # 进入存放项目的文件夹（自定义的）sh stop.sh # 停止正在运行的旧版本项目 shell脚本sh replace.sh # 替换编译后的jar包 shell脚本#启动新编译打包的项目BUILD_ID=dontKillMe nohup java -jar /usr/local/javaProject/springboot_swagger_dome-0.0.1-SNAPSHOT.jar &amp; stop.sh 和 replace.sh 内容： 12345678#stop.sh#找到正在运行旧项目的 编号#然后停止pid=`ps -ef | grep springboot_swagger_dome-0.0.1-SNAPSHOT.jar | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`if [ -n &quot;$pid&quot; ]then kill -9 $pidfi 12345678910#replate.sh#判断指定路径下的jar包是否存在#如果存在，更名备份#将Jenkins打包编译后的项目移动到指定的项目目录下file=&quot;/usr/local/javaProject/springboot_swagger_dome-0.0.1-SNAPSHOT.jar&quot;if [ -f &quot;$file&quot; ]then mv /usr/local/javaProject/springboot_swagger_dome-0.0.1-SNAPSHOT.jar /usr/local/javaProject/springboot_swagger_dome-0.0.1-SNAPSHOT.jar.`date +%Y%m%d%H%M%S`fi mv /root/.jenkins/workspace/test_autodelpment/target/springboot_swagger_dome-0.0.1-SNAPSHOT.jar /usr/local/javaProject/ 测试配置完成后点击立即构建即可执行，可以点击构建历史中的记录&#x3D;&gt;控制台输出，中查看构建控制台输出。","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"author":["extends"]},{"title":"ubuntu更换apt源","slug":"ubuntu更换apt源","date":"2023-04-08T08:47:23.000Z","updated":"2023-04-08T09:05:07.325Z","comments":true,"path":"2023/04/08/ubuntu更换apt源/","link":"","permalink":"http://example.com/2023/04/08/ubuntu%E6%9B%B4%E6%8D%A2apt%E6%BA%90/","excerpt":"","text":"Ubuntu更换apt国内源修改/etc/apt/sources.list配置文件 使用vim编辑器在文件最前面添加内容 vim命令 1$ sudo vim /etc/apt/sources.list 添加内容（阿里源） 12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 保存并退出（vim：w保存；q退出） 更新缓存 12$ sudo apt-get update$ sudo apt-get upgrade 其他数据源清华源 12345678910deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 中科大 12345678910deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 163源 12345678910deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"author":["extends"]},{"title":"MySQL中group的用法","slug":"MySQL中group的用法","date":"2023-04-03T10:46:09.000Z","updated":"2023-04-03T10:46:54.845Z","comments":true,"path":"2023/04/03/MySQL中group的用法/","link":"","permalink":"http://example.com/2023/04/03/MySQL%E4%B8%ADgroup%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"说明：group 一般和聚合函数一起使用，后面可以跟上 HAVING 关键字一起使用。(having 和 where 用法相同，不同的是having可以后跟聚合函数) 关键字 用法 缺点 WHERE 先筛选数据再关联，执行效率高 不能使用分组中的计算函数进行筛选 HAVING 可以使用分组中的计算函数 在最后的结果集中进行筛选，执行效率较低 聚合函数 count() 求行数 sum() 求某列行的值 avg() 求某列的平均值 max() 求某列最大值 min() 求某列最小值 示例有如下表 id name money 1 张三 200 2 张三 100 3 李四 50 4 李四 600 5 王五 400 6 张三 600 使用SQL语句分组查询 12345SELECT `name`, SUM(money)FROM `test`GROUP BY `name` 说明：根据姓名分组统计每个的金钱总数 结果 123张三 900.00李四 650.00王五 400.00","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}],"author":["extends"]},{"title":"maven打包命令","slug":"maven打包命令","date":"2023-04-01T01:18:23.000Z","updated":"2023-04-01T01:19:31.537Z","comments":true,"path":"2023/04/01/maven打包命令/","link":"","permalink":"http://example.com/2023/04/01/maven%E6%89%93%E5%8C%85%E5%91%BD%E4%BB%A4/","excerpt":"","text":"一、常用命令 命令 描述 mvn clean 对项目进行清理，删除target目录下编译的内容 mvn compile 编译项目源代码 mvn test 对项目进行运行测试 mvn package 打包文件并存放到项目的target目录下，打包好的文件通常都是编译后的class文件 mvn install 在本地仓库生成仓库的安装包，可供其他项目引用，同时打包后的文件放到项目的target目录下 二、跳过单元测试跳过单元测试同时也跳过测试代码的编译 1mvn package -Dmaven.test.skip=true 跳过单元测试，不跳过测试代码的编译 1mvn package -DskipTests 三、命令组合使用1mvn clean install package -Dmaven.test.skip=true 依次执行clean、install、package，并跳过测试代码的编译和运行。","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"}],"author":["extends"]},{"title":"Java中Duration类和Period类的使用方法","slug":"Java中Duration类和Period类的使用方法","date":"2023-03-30T09:08:10.000Z","updated":"2023-03-30T09:09:14.871Z","comments":true,"path":"2023/03/30/Java中Duration类和Period类的使用方法/","link":"","permalink":"http://example.com/2023/03/30/Java%E4%B8%ADDuration%E7%B1%BB%E5%92%8CPeriod%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"说明Duration类通过秒和纳秒相结合来描述一个时间量，最高精度是纳秒。时间量可以为正也可以为负，比如1天（86400秒0纳秒）、-1天（-86400秒0纳秒）、1年（31556952秒0纳秒）、1毫秒（0秒1000000纳秒）等。 Period类通过年、月、日相结合来描述一个时间量，最高精度是天。时间量可以为正也可以为负，例如2年（2年0个月0天）、3个月（0年3个月0天）、4天（0年0月4天）等。 这两个类是不可变的、线程安全的、最终类。都是JDK8新增的。 Duration创建方法通过时间单位创建基于天、时、分、秒、纳秒创建。 ofDays(), ofHours(), ofMillis(), ofMinutes(), ofNanos(), ofSeconds()。例如： 1Duration fromDays = Duration.ofDays(1); 通过LocalDateTime或LocalTime通过LocalDateTime或者LocalTime 类，然后使用between获取创建Duration。 1234LocalDateTime start = LocalDateTime.of(2022, 1, 1, 8, 0, 0);LocalDateTime end = LocalDateTime.of(2022, 1, 2, 8, 30, 30);// 表示两个时间的相差时间Duration duration = Duration.between(start, end); 通过已有的Duration12Duration du1 = Duration.ofHours(10);Duration duration = Duration.from(du1); 解析方法用法示例 12Duration fromChar1 = Duration.parse(&quot;P1DT1H10M10.5S&quot;);Duration fromChar2 = Duration.parse(&quot;PT10M&quot;); 格式说明 采用ISO-8601时间格式。格式为：PnYnMnDTnHnMnS （n为个数） 例如：P1Y2M10DT2H30M15.03S P：开始标记 1Y：一年 2M：两个月 10D：十天 T：日期和时间的分割标记 2H：两个小时 30M：三十分钟 15S：15.02秒 详解 1.”P”, “D”, “H”, “M” 和 “S”可以是大写或者小写（建议大写） 2.可以用“-”表示负数 示例 12345678&quot;PT20.345S&quot; -- parses as &quot;20.345 seconds&quot;&quot;PT15M&quot; -- parses as &quot;15 minutes&quot; (where a minute is 60 seconds)&quot;PT10H&quot; -- parses as &quot;10 hours&quot; (where an hour is 3600 seconds)&quot;P2D&quot; -- parses as &quot;2 days&quot; (where a day is 24 hours or 86400 seconds)&quot;P2DT3H4M&quot; -- parses as &quot;2 days, 3 hours and 4 minutes&quot;&quot;P-6H3M&quot; -- parses as &quot;-6 hours and +3 minutes&quot;&quot;-P6H3M&quot; -- parses as &quot;-6 hours and -3 minutes&quot;&quot;-P-6H+3M&quot; -- parses as &quot;+6 hours and -3 minutes&quot; 常用API方法比较两个时间差1234567891011Instant start = Instant.parse(&quot;2023-01-03T10:15:30.00Z&quot;);Instant end = Instant.parse(&quot;2023-01-04T10:15:30.00Z&quot;);// end - startDuration duration = Duration.between(start, end);// 任何一个时间单元为负数，则返回trueSystem.out.println(&quot;是否为负数:&quot; + duration.isNegative());// 转换为秒，最高精度是纳秒System.out.println(&quot;秒:&quot; + duration.getSeconds());System.out.println(&quot;纳秒:&quot; + duration.getNano()); 增减方法 plusXxx()、minusXxx()增减包括：days, hours, millis, minutes, nanos 或 seconds 123Duration duration = Duration.ofHours(2);// 在原有基础上增加30秒Duration newDuration = duration.plusSeconds(30); 转换单位 toXxx()可以用toXxx来转换为其他单位，支持：toDays, toHours, toMinutes, toMillis, toNanos 1234567Duration duration = Duration.ofHours(2); duration.toDays(); // 0duration.toHours(); // 2duration.toMinutes(); // 120duration.toMillis(); // 7200000duration.toNanos(); // 7200000000000 取值方法可以用getXxx来获得指定位置的值，因为Duration是由秒和纳秒组成，所以只能获得秒和纳秒： 123Duration duration = Duration.ofHours(2);duration.getSeconds(); // 7200duration.getNano(); // 0 Period创建方法通过时间单位创建如果仅一个值表示，如使用ofDays()方法，那么其他值为0。 若仅用ofWeeks，则其天数为week数乘以7. 12345Period fromUnits = Period.of(3, 10, 10);Period fromDays = Period.ofDays(50);Period fromMonths = Period.ofMonths(5);Period fromYears = Period.ofYears(10);Period fromWeeks = Period.ofWeeks(40); //280天 通过LocalDate创建1234LocalDate startDate = LocalDate.of(2015, 2, 20);LocalDate endDate = LocalDate.of(2017, 1, 15);// startDate减endDatePeriod period = Period.between(startDate, endDate); 解析方法格式：“PnYnMnWnD” P：开始符，表示period（即：表示年月日）； Y：year； M：month； W：week； D：day P, Y, M, W, D都可以用大写或者小写。 123Period period = Period.parse(&quot;P2Y&quot;); //2年Period period = Period.parse(&quot;P2Y3M5D&quot;); //2年3月5天Period period = Period.parse(&quot;P1Y2M3W4D&quot;); // 1年2月3周4天。即：1年2月25天 常用API方法比较方法用between来比较日期。 123456LocalDate startDate = LocalDate.of(2015, 2, 20);LocalDate endDate = LocalDate.of(2017, 1, 15); // endDate - startDatePeriod period = Period.between(startDate, endDate);// 任何一个时间单元为负数则返回trueperiod.isNegative() 增减方法 plusXxx()、minusXxx()123Period period = Period.parse(&quot;P2Y3M5D&quot;);period.plusDays(50);period.minusMonths(2); 转换单位 toXxx()12Period period = Period.parse(&quot;P1Y2M3D&quot;);period.toTotalMonths(); // 14 取值方法1234Period period = Period.parse(&quot;P1Y2M3D&quot;);period.getYears(); // 1period.getMonths(); // 2period.getDays(); // 3","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}],"author":["extends"]},{"title":"mybatisplus快速配置使用","slug":"mybatisplus快速配置使用","date":"2023-03-18T05:21:05.000Z","updated":"2023-03-18T05:23:48.053Z","comments":true,"path":"2023/03/18/mybatisplus快速配置使用/","link":"","permalink":"http://example.com/2023/03/18/mybatisplus%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1. 引入maven依赖123456&lt;!-- mybatis-plus --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt; starter包中已经包括mybatis依赖，只需要引入一个starter包即可。 2. 配置配置yaml文件 123456789101112131415161718spring: application: name: xiaoyi datasource: url: jdbc:mysql://192.168.13.130:3306/oauth_admin?useUnicode=TRUE&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;serverTimezone=UTC&amp;useSSL=false type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver username: root password: rootmybatis-plus: global-config: db-config: id-type: auto configuration: map-underscore-to-camel-case: true auto-mapping-behavior: full log-impl: org.apache.ibatis.logging.stdout.StdOutImpl mapper-locations: classpath:mapper/*.xml 创建配置类，配置mybatisplus的分页插件。 1234567@Configurationpublic class MybatisPlusConfig &#123; @Bean public PaginationInterceptor paginationInterceptor()&#123; return new PaginationInterceptor(); &#125;&#125; 3. 编写实体类抽离公共字段，编写BaseEntity其他业务类继承该基础类。 BaseEntity.java 1234567891011121314151617181920212223242526272829303132333435363738import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.fasterxml.jackson.annotation.JsonFormat;import com.fasterxml.jackson.databind.annotation.JsonSerialize;import lombok.Data;import java.io.Serializable;import java.util.Date;@Data// 实现序列化接口public class BaseEntity implements Serializable &#123; @TableField(exist = false) private static final long serialVersionUID = 1L; @TableId(value = &quot;id&quot;, type = IdType.AUTO) private Long id; /** * 创建日期 */ @JsonSerialize(using=CustomDateTimeSerializer.class) @JsonFormat(pattern =&quot;yyyy-MM-dd HH:mm:ss&quot;) private Date createTime; /** * 更新日期 */ @JsonSerialize(using=CustomDateTimeSerializer.class) @JsonFormat(pattern =&quot;yyyy-MM-dd HH:mm:ss&quot;) private Date updateTime; /** * 备注 */ @TableField(value = &quot;remark&quot;) private String remark;&#125; SysRole.java 123456789101112131415161718192021222324import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;/** * @TableName sys_role */@TableName(value =&quot;sys_role&quot;)@Datapublic class SysRole extends BaseEntity &#123; /** * 角色名称 */ @TableField(value = &quot;name&quot;) private String name; /** * 角色权限字符串 */ @TableField(value = &quot;code&quot;) private String code;&#125; 3. 编写Mapper层mapper层接口需要继承BaseMapper&lt;SysRole&gt;，泛型为对应的实体类对象。 1234import com.xiaoyi.entity.SysRole;import com.baomidou.mybatisplus.core.mapper.BaseMapper;public interface SysRoleMapper extends BaseMapper&lt;SysRole&gt; &#123;&#125; 4. 编写Service层service层需要继承ServiceImpl&lt;SysRoleMapper, SysRole&gt;类，泛型分别为对应的mapper接口和实体类对象。 1234567891011import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.xiaoyi.entity.SysRole;import com.xiaoyi.service.SysRoleService;import com.xiaoyi.mapper.SysRoleMapper;import org.springframework.stereotype.Service;@Servicepublic class SysRoleServiceImpl extends ServiceImpl&lt;SysRoleMapper, SysRole&gt; implements SysRoleService&#123;&#125; 5. 编写Controller并测试编写接口调用测试是否成功。 123456789101112131415161718192021222324252627282930313233343536373839404142import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.xiaoyi.entity.*;import com.xiaoyi.service.SysRoleMenuService;import com.xiaoyi.service.SysRoleService;import org.springframework.security.access.prepost.PreAuthorize;import org.springframework.transaction.annotation.Transactional;import org.springframework.util.StringUtils;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;import java.util.*;import java.util.stream.Collectors;@RestController@RequestMapping(&quot;/sys/role&quot;)public class SysRoleController &#123; @Resource private SysRoleService roleService; /** * @description 分页查询角色 * @param pageBean 分页 * @return com.xiaoyi.entity.ResultBody * @author 小易 * @date 2022/12/16 13:41 */ @GetMapping(&quot;/list&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;system:role:query&#x27;)&quot;) public ResultBody list(PageBean pageBean)&#123; String query = pageBean.getQuery(); Page&lt;SysRole&gt; page = roleService.page( new Page&lt;&gt;(pageBean.getPageNum(), pageBean.getPageSize()), new QueryWrapper&lt;SysRole&gt;().like(StringUtils.hasText(query),&quot;name&quot;,query)); List&lt;SysRole&gt; roleList = page.getRecords(); Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;(); resultMap.put(&quot;roleList&quot;, roleList); resultMap.put(&quot;total&quot;, page.getTotal()); return ResultBody.success(resultMap); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://example.com/tags/mybatis/"}],"author":["extends"]},{"title":"# springboot解决中文乱码","slug":"springboot解决中文乱码","date":"2023-03-16T09:03:23.000Z","updated":"2023-03-18T05:24:01.809Z","comments":true,"path":"2023/03/16/springboot解决中文乱码/","link":"","permalink":"http://example.com/2023/03/16/springboot%E8%A7%A3%E5%86%B3%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","excerpt":"","text":"通过实现WebMvcConfigurer，重写configureMessageConverters方法，自定义转换器。 123456789@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; StringHttpMessageConverter converter = new StringHttpMessageConverter(Charset.forName(&quot;UTF-8&quot;)); converters.add(converter); &#125;&#125; 通过继承WebMvcConfigurationSupport 123456789@Configurationpublic class MyTestConfig extends WebMvcConfigurationSupport &#123; @Override protected void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; StringHttpMessageConverter converter = new StringHttpMessageConverter(StandardCharsets.UTF_8); converters.add(converter); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://example.com/tags/springboot/"}],"author":["extends"]},{"title":"swagger配置教程","slug":"swagger配置教程","date":"2023-03-08T03:16:05.000Z","updated":"2023-03-08T03:17:07.709Z","comments":true,"path":"2023/03/08/swagger配置教程/","link":"","permalink":"http://example.com/2023/03/08/swagger%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/","excerpt":"","text":"实时接口文档就是可以根据代码来自动生成相应的接口文档，优点就是我们的代码发生变化时，生成的接口文档也会自动更新，无需我们去修改接口文档，只需要按时发布即可。但是由于是根据代码自动生成的，所以最大的弊端就是代码侵入性强，需要我们在项目代码中集成生成接口文档的相关代码。 SpringBoot集成swagger2引入依赖12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 引入配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.ParameterBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.schema.ModelRef;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Parameter;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;import java.util.ArrayList;import java.util.List;@Configuration// 该注解必须开启，也可以在spring启动类上开启@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket createRestApi() &#123; // Docket配置，就是一组(一个项目或一个版本)接口文档的配置，比如设置名称， 联系人等 return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() // 扫描路径下的所有类 .apis(RequestHandlerSelectors.basePackage(&quot;com.swagger.springboot_swagger_dome.controller&quot;)) .paths(PathSelectors.any()) .build() .globalOperationParameters(setHeaderToken()); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;action-swagger&quot;) .description(&quot;swagger实战&quot;) .termsOfServiceUrl(&quot;&quot;) .version(&quot;1.0&quot;) .build(); &#125; /** * 设置swagger文档中全局参数，所有接口中都要包含一个header类型的token参数 */ private List&lt;Parameter&gt; setHeaderToken() &#123; List&lt;Parameter&gt; pars = new ArrayList&lt;&gt;(); ParameterBuilder userId = new ParameterBuilder(); userId.name(&quot;token&quot;).description(&quot;用户TOKEN&quot;).modelRef(new ModelRef(&quot;string&quot;)).parameterType(&quot;header&quot;) .required(true).build(); pars.add(userId.build()); return pars; &#125;&#125; 给Controller 添加注解接口文档的直接描述主要就是在Controller这一层，比如这个接口的功能，参数的名称，返回值的名称等。这些值我们都需要在Controller上通过给方法上，请求参数和返回参数上添加对应的注解，swagger才能帮我们生成相应的接口文档。 请求类 1234567891011121314151617import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;@Data@ApiModel(&quot;创建Swagger请求参数&quot;)public class SwaggerReqVO &#123; @ApiModelProperty(&quot;id&quot;) private Integer id; @ApiModelProperty(&quot;姓名&quot;) private String name; @ApiModelProperty(&quot;性别&quot;) private Integer gender;&#125; 响应类 1234567891011121314151617181920import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;@Data@ApiModel(&quot;创建Swagger响应结果&quot;)public class SwaggerResVO &#123; @ApiModelProperty(&quot;id&quot;) private Integer id; @ApiModelProperty(&quot;姓名&quot;) private String name; @ApiModelProperty(&quot;性别&quot;) private Integer gender; @ApiModelProperty(&quot;嘛&quot;) private String what;&#125; Controller 1234567891011121314151617181920212223import com.swagger.springboot_swagger_dome.vo.SwaggerReqVO;import com.swagger.springboot_swagger_dome.vo.SwaggerResVO;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(&quot;/swagger&quot;)@Api(value = &quot;用户接口&quot;, tags = &#123;&quot;用户接口&quot;&#125;)public class SwaggerController &#123; @ApiOperation(&quot;新增用户&quot;) @PostMapping(&quot;save&quot;) public String save(@RequestBody SwaggerReqVO req) &#123; return &quot;success&quot;; &#125; @GetMapping(&quot;getById&quot;) @ApiOperation(&quot;根据条件查询用户&quot;) public SwaggerResVO getById(@RequestBody SwaggerResVO req) &#123; return new SwaggerResVO(); &#125;&#125; 访问地址： ip:端口号&#x2F;swagger-ui.html 可能出现的问题可能会出现以下错误：org.springframework.context.ApplicationContextException: Failed to start bean &#39;documentationPluginsBootstrapper&#39;; 12345678910111213141516org.springframework.context.ApplicationContextException: Failed to start bean &#x27;documentationPluginsBootstrapper&#x27;; nested exception is java.lang.NullPointerException at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:181) ~[spring-context-5.3.25.jar:5.3.25] at org.springframework.context.support.DefaultLifecycleProcessor.access$200(DefaultLifecycleProcessor.java:54) ~[spring-context-5.3.25.jar:5.3.25] at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:356) ~[spring-context-5.3.25.jar:5.3.25] at java.base/java.lang.Iterable.forEach(Iterable.java:75) ~[na:na] at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:155) ~[spring-context-5.3.25.jar:5.3.25] at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:123) ~[spring-context-5.3.25.jar:5.3.25] at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:935) ~[spring-context-5.3.25.jar:5.3.25] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:586) ~[spring-context-5.3.25.jar:5.3.25] at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:147) ~[spring-boot-2.7.8.jar:2.7.8] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:731) ~[spring-boot-2.7.8.jar:2.7.8] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:408) ~[spring-boot-2.7.8.jar:2.7.8] at org.springframework.boot.SpringApplication.run(SpringApplication.java:307) ~[spring-boot-2.7.8.jar:2.7.8] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1303) ~[spring-boot-2.7.8.jar:2.7.8] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1292) ~[spring-boot-2.7.8.jar:2.7.8] at com.swagger.springboot_swagger_dome.SpringbootSwaggerDomeApplication.main(SpringbootSwaggerDomeApplication.java:10) ~[classes/:na] 这个问题的主要原因确实是SpringBoot版本过高导致。如果用的是SpringBoot2.5.x及之前版本是没有问题的。 Spring Boot 2.6.X使用PathPatternMatcher匹配路径，Swagger引用的Springfox使用的路径匹配是基于AntPathMatcher的。 所以要想解决，添加配置，将springBoot MVC的路劲匹配模式修改一下即可。 1spring.mvc.pathmatch.matching-strategy=ANT_PATH_MATCHER 1234spring: mvc: pathmatch: matching-strategy: ANT_PATH_MATCHER swagger常用注解1、**@Api()**：用在请求的类上，表示对类的说明，也代表了这个类是swagger2的资源 参数： 123tags：说明该类的作用，参数是个数组，可以填多个。value=&quot;该参数没什么意义，在UI界面上不显示，所以不用配置&quot;description = &quot;用户基本信息操作&quot; 2、**@ApiOperation()**：用于方法，表示一个http请求访问该方法的操作 参数： 12345value=&quot;方法的用途和作用&quot; notes=&quot;方法的注意事项和备注&quot; tags：说明该方法的作用，参数是个数组，可以填多个。格式：tags=&#123;&quot;作用1&quot;,&quot;作用2&quot;&#125; （在这里建议不使用这个参数，会使界面看上去有点乱，前两个常用） 3、**@ApiModel()**：用于响应实体类上，用于说明实体作用 参数： 1description=&quot;描述实体的作用&quot; 4、**@ApiModelProperty**：用在属性上，描述实体类的属性 参数： 123value=&quot;用户名&quot; 描述参数的意义name=&quot;name&quot; 参数的变量名required=true 参数是否必选 5、**@ApiImplicitParams**：用在请求的方法上，包含多@ApiImplicitParam 6、**@ApiImplicitParam**：用于方法，表示单独的请求参数 参数： 1234567891011name=&quot;参数ming&quot; value=&quot;参数说明&quot; dataType=&quot;数据类型&quot; paramType=&quot;query&quot; 表示参数放在哪里 · header 请求参数的获取：@RequestHeader · query 请求参数的获取：@RequestParam · path（用于restful接口） 请求参数的获取：@PathVariable · body（不常用） · form（不常用） defaultValue=&quot;参数的默认值&quot;required=&quot;true&quot; 表示参数是否必须传 7、**@ApiParam()**：用于方法，参数，字段说明 表示对参数的要求和说明 参数： 1234name=&quot;参数名称&quot;value=&quot;参数的简要说明&quot;defaultValue=&quot;参数默认值&quot;required=&quot;true&quot; 表示属性是否必填，默认为false 8、**@ApiResponses**：用于请求的方法上，根据响应码表示不同响应 一个@ApiResponses包含多个@ApiResponse 9、**@ApiResponse**：用在请求的方法上，表示不同的响应 参数： 12code=&quot;404&quot; 表示响应码(int型)，可自定义message=&quot;状态码对应的响应信息&quot; 10、**@ApiIgnore()**：用于类或者方法上，不被显示在页面上 11、**@Profile({“dev”, “test”})**：用于配置类上，表示只对开发和测试环境有用","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"swagger","slug":"swagger","permalink":"http://example.com/tags/swagger/"}],"author":["extends"]},{"title":"前后端分离项目跨域问题","slug":"前后端分离项目跨域问题","date":"2023-01-03T08:43:54.000Z","updated":"2023-01-03T09:31:25.000Z","comments":true,"path":"2023/01/03/前后端分离项目跨域问题/","link":"","permalink":"http://example.com/2023/01/03/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"方法一：SpringBoot后端进行处理在 每个 Controller 类上加入 @CrossOrigin 注解 或者 在 Controller的基类中加上 @CrossOrigin 注解然后其他 Controller 类就有了这个 @Controller此时跨域访问就不会报错了。 方法二：在Vue前端进行处理浏览器 在同一个页面访问不同的域 是存在跨域问题的 但 服务器之间的访问是 没有跨域问题 因此 需要在前端设置代理， 通过代理访问 SpringBoot后端API 安装代理 1cnpm install --save-dev http-proxy-middleware 配置请求 baseURL 在 src &#x2F; utils &#x2F; request.js 中 12345678910// 创建axios实例const service = axios.create(&#123; // axios中请求配置有baseURL选项，表示请求URL公共部分 // baseURL: &#x27;http://127.0.0.1:8888/ruoyi&#x27;, baseURL: &#x27;/api&#x27;, // changeOrigin: true, // 超时 timeout: 10000&#125;) 配置 proxy 在 vue.config.js 中 1234567891011121314151617module.exports = &#123; devServer: &#123; // 自动打开浏览器 open: true, port: 70, proxy: &#123; // // detail: https://cli.vuejs.org/config/#devserver-proxy &#x27;/api&#x27;: &#123; target: `http://localhost:8888/ruoyi`, changeOrigin: true, pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125; &#125; &#125; &#125;&#125; login.vue 页面发送验证码的请求 请求 API 12345678import request from &#x27;@/utils/request&#x27;// 获取验证码export function getCodeImg() &#123; return request(&#123; url: &#x27;/captcha/captchaImage?type=math&#x27;, method: &#x27;get&#x27; &#125;)&#125; 总结 跨域解决方案有很多种，如 使用 nginx代理 使用 filter 添加头信息 使用 @CrossOrigin 注解 使用 proxy 代理","categories":[{"name":"前后端","slug":"前后端","permalink":"http://example.com/categories/%E5%89%8D%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF/"}],"author":["extends"]},{"title":"axios发post请求，后端接收不到参数的解决方案","slug":"axios发post请求，后端接收不到参数的解决方案","date":"2022-12-12T09:51:18.000Z","updated":"2023-01-03T09:31:39.000Z","comments":true,"path":"2022/12/12/axios发post请求，后端接收不到参数的解决方案/","link":"","permalink":"http://example.com/2022/12/12/axios%E5%8F%91post%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%90%8E%E7%AB%AF%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%88%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"问题原因原因就是这次的接口使用 java spring mvc并且在这个方法上使用了注解 @RequestParam 这个是只能从请求的地址中取出参数，也就是只能从 username&#x3D;admin&amp;password&#x3D;admin 这种字符串中解析出参数。我们还可以看到我们这次请求的 Content-Type : 1application/json;charset=UTF-8 axios会帮我们 转换请求数据和响应数据 以及 自动转换 JSON 数据 问题分析也就是说，我们的 Content-Type 变成了 application/json;charset=utf-8然后，因为我们的参数是 JSON 对象，axios 帮我们做了一个 stringify 的处理。而且查阅 axios 文档可以知道：axios 使用 post 发送数据时，默认是直接把 json 放到请求体中提交到后端的。 那么，这就与我们服务端要求的 &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39; 以及 @RequestParam 不符合。 解决方案一【用 URLSearchParams 传递参数】 12345678let param = new URLSearchParams()param.append(&#x27;username&#x27;, &#x27;admin&#x27;)param.append(&#x27;pwd&#x27;, &#x27;admin&#x27;)axios(&#123; method: &#x27;post&#x27;, url: &#x27;/api/lockServer/search&#x27;, data: param&#125;) 需要注意的是： URLSearchParams 不支持所有的浏览器，但是总体的支持情况还是 OK 的，所以优先推荐这种简单直接的解决方案 解决方案二【还需要额外的操作，（我们要将参数转换为query参数）】引入 qs ，这个库是 axios 里面包含的，不需要再下载了。 1234567891011121314import Qs from &#x27;qs&#x27;let data = &#123; &quot;username&quot;: &quot;admin&quot;, &quot;pwd&quot;: &quot;admin&quot;&#125;axios(&#123; headers: &#123; &#x27;deviceCode&#x27;: &#x27;A95ZEF1-47B5-AC90BF3&#x27; &#125;, method: &#x27;post&#x27;, url: &#x27;/api/lockServer/search&#x27;, data: Qs.stringify(data)&#125;) 解决方案三 我们知道现在我们服务端同学接收参数用的是 @RequestParam（通过字符串中解析出参数）其实还有另一种是 @RequestBody（从请求体中获取参数）。 后端改成 @RequestBody 就可以了","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"前端/axios","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/axios/"}],"tags":[{"name":"axios","slug":"axios","permalink":"http://example.com/tags/axios/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}],"author":["extends"]},{"title":"axios发送四种请求方式","slug":"axios发送四种请求方式","date":"2022-12-12T09:31:20.000Z","updated":"2023-01-03T09:31:35.000Z","comments":true,"path":"2022/12/12/axios发送四种请求方式/","link":"","permalink":"http://example.com/2022/12/12/axios%E5%8F%91%E9%80%81%E5%9B%9B%E7%A7%8D%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/","excerpt":"","text":"get和 delete请求传递参数 通过传统的url 以 ? 的形式传递参数 restful 形式传递参数 通过params 形式传递参数 post 和 put 请求传递参数 通过选项传递参数 通过 URLSearchParams 传递参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 1. 发送get 请求 axios.get(&#x27;http://localhost:3000/adata&#x27;).then(function(ret)&#123; // 拿到 ret 是一个对象 所有的对象都存在 ret 的data 属性里面 // 注意data属性是固定的用法，用于获取后台的实际数据 // console.log(ret.data) console.log(ret)&#125;)// 2. get 请求传递参数// 2.1 通过传统的url 以 ? 的形式传递参数axios.get(&#x27;http://localhost:3000/axios?id=123&#x27;).then(function(ret)&#123; console.log(ret.data)&#125;)// 2.2 restful 形式传递参数 axios.get(&#x27;http://localhost:3000/axios/123&#x27;).then(function(ret)&#123; console.log(ret.data)&#125;)// 2.3 通过params 形式传递参数 axios.get(&#x27;http://localhost:3000/axios&#x27;, &#123; params: &#123; id: 789 &#125;&#125;).then(function(ret)&#123; console.log(ret.data)&#125;)// 3 axios delete 请求传参 传参的形式和 get 请求一样axios.delete(&#x27;http://localhost:3000/axios&#x27;, &#123; params: &#123; id: 111 &#125;&#125;).then(function(ret)&#123; console.log(ret.data)&#125;)// 4 axios 的 post 请求// 4.1 通过选项传递参数axios.post(&#x27;http://localhost:3000/axios&#x27;, &#123; uname: &#x27;lisi&#x27;, pwd: 123&#125;).then(function(ret)&#123; console.log(ret.data)&#125;)// 4.2 通过 URLSearchParams 传递参数 var params = new URLSearchParams();params.append(&#x27;uname&#x27;, &#x27;zhangsan&#x27;);params.append(&#x27;pwd&#x27;, &#x27;111&#x27;);axios.post(&#x27;http://localhost:3000/axios&#x27;, params).then(function(ret)&#123; console.log(ret.data)&#125;)// 5 axios put 请求传参 和 post 请求一样 axios.put(&#x27;http://localhost:3000/axios/123&#x27;, &#123; uname: &#x27;lisi&#x27;, pwd: 123&#125;).then(function(ret)&#123; console.log(ret.data)&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"前端/axios","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/axios/"}],"tags":[{"name":"axios","slug":"axios","permalink":"http://example.com/tags/axios/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}],"author":["extends"]},{"title":"docker笔记","slug":"docker笔记","date":"2022-12-09T08:14:47.000Z","updated":"2023-01-03T09:31:46.000Z","comments":true,"path":"2022/12/09/docker笔记/","link":"","permalink":"http://example.com/2022/12/09/docker%E7%AC%94%E8%AE%B0/","excerpt":"","text":"安装dockerDocker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。 Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。 所以，Docker 必须部署在 Linux 内核的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。 Linux系统安装与卸载使用官方安装脚本自动安装安装命令如下： 1curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 也可以使用国内 daocloud 一键安装命令： 1curl -sSL https://get.daocloud.io/docker | sh curl是一个利用 URL 语法，在终端下使用的网络请求工具，支持 HTTP、HTTPS、FTP 等协议。CURL 也有用于程序开发使用的版本 libcurl。 Linux、MAC 一般系统默认已安装好 curl，直接在终端使用命令即可，如果需要手动安装，可以到 curl.haxx.se 下载安装。 卸载 docker删除安装包： 1yum remove docker-ce 删除镜像、容器、配置文件等内容： 1rm -rf /var/lib/docker 使用docker命令基本上都是以docker开头。 docker要运行首先需要有一个镜像(images)，通过镜像创建容器，之后在容器中即可进行自己的操作。 这一点可以理解为java中首先需要有一个类，然后通过new 类名 的方式创建出这个类的实例之后才可以使用这个类一样。 Docker命令一览图 &#x3D;&#x3D;使用docker镜像可以到dockerhub上搜索查询某一镜像的使用方法&#x3D;&#x3D; https://hub.docker.com/ Docker原理理解一、镜像是什么​ 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。所有的应用，直接打包docker镜像，就可以直接跑起来！如何得到镜像： 从远程仓库下载 朋友拷贝给你 自己制作一个镜像DockerFile 二、Docker镜像加速原理UnionFS（联合文件系统） 我们下载的时候看到的一层层就是这个！UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union 文件系统是Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。 Docker镜像加载原型 docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。 bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。 rootfs（root file system），在bootfs之上。包含的就是典型Linux系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。（虚拟机是分钟级，容器是秒级！） 三、分层理解分层的镜像 下载一个镜像，观察其下载的日志输出，可以看到是一层一层的在下载！ 思考：为什么Docker镜像要采用这种分层的结构呢？最大的好处，我觉得莫过于是资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。查看镜像分层的方式可以通过 docker image inspect命令！ 123456789101112131415161718[ // ...... &quot;RootFS&quot;: &#123; &quot;Type&quot;: &quot;layers&quot;, &quot;Layers&quot;: [ &quot;sha256:2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f&quot;, &quot;sha256:9b24afeb7c2f21e50a686ead025823cd2c6e9730c013ca77ad5f115c079b57cb&quot;, &quot;sha256:4b8e2801e0f956a4220c32e2c8b0a590e6f9bd2420ec65453685246b82766ea1&quot;, &quot;sha256:529cdb636f61e95ab91a62a51526a84fd7314d6aab0d414040796150b4522372&quot;, &quot;sha256:9975392591f2777d6bf4d9919ad1b2c9afa12f9a9b4d260f45025ec3cc9b18ed&quot;, &quot;sha256:8e5669d8329116b8444b9bbb1663dda568ede12d3dbcce950199b582f6e94952&quot; ] &#125;, &quot;Metadata&quot;: &#123; &quot;LastTagTime&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125; &#125;] 理解：所有的Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。举一个简单的例子，假如基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。该镜像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。 在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。 上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版本。 这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。Linux上可用的存储引擎有AUFS、Overlay2、Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。Docker在Windows 上仅支持 windowsfilter一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW[1]。下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。 特点 Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！这一层就是我们通常说的容器层，容器之下的都叫镜像层！ 四、个人理解类似Git的版本控制 每次commit都是提交新改动，commit出来的新镜像就作为镜像层，运行该镜像时就会在添加一个可编辑的容器层。 Docker 镜像使用查看本地镜像当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。 使用指令docker images查看本地主机上的所有镜像。 123REPOSITORY TAG IMAGE ID CREATED SIZEredis latest 3358aea34e8c 2 weeks ago 117MBubuntu latest a8780b506fa4 4 weeks ago 77.8MB REPOSITORY：表示镜像的仓库源 TAG：镜像的标签 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 使用镜像使用指令docker run -t -i ubuntu[:指定版本] /bin/bash 运行容器 -i: 交互式操作。 -t: 终端。 ubuntu:[15.10]: 这是指用 ubuntu 15.10 版本镜像为基础来启动容器。 &#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。 1$ docker run -t -i ubuntu:15.10 /bin/bash 下载新镜像使用指令docker pull [需要下载的镜像:版本]下载指定镜像。 1$ docker pull ubuntu:13.10 删除镜像使用指令docker rmi [镜像名称]删除指定镜像 1$ docker rmi ubuntu:15.10 创建镜像当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。 1、从已经创建的容器中更新镜像，并且提交这个镜像 2、使用 Dockerfile 指令来创建一个新的镜像 更新镜像更新镜像之前，我们需要使用镜像来创建一个容器。 1$ docker run -t -i ubuntu:15.10 /bin/bash 在运行的容器内使用 apt-get update 命令进行更新。 在完成操作之后，输入 exit 命令来退出这个容器。 此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。 1$ docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2 各个参数说明： -m: 提交的描述信息 -a: 指定镜像作者 e218edb10161：容器 ID runoob&#x2F;ubuntu:v2: 指定要创建的目标镜像名 我们可以使用 docker images 命令来查看我们的新镜像 runoob&#x2F;ubuntu:v2： 1234567891011runoob@runoob:~$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZErunoob/ubuntu v2 70bf1840fd7c 15 seconds ago 158.5 MBubuntu 14.04 90d5884b1ee0 5 days ago 188 MBphp 5.6 f40e9e0f10c8 9 days ago 444.8 MBnginx latest 6f8d099c3adc 12 days ago 182.7 MBmysql 5.6 f2e8d6c772c0 3 weeks ago 324.6 MBhttpd latest 02ef73cf1bc0 3 weeks ago 194.4 MBubuntu 15.10 4e3b13c8a266 4 weeks ago 136.3 MBhello-world latest 690ed74de00f 6 months ago 960 Btraining/webapp latest 6fae60ef3446 12 months ago 348.8 MB 使用我们的新镜像 runoob&#x2F;ubuntu 来启动一个容器 1runoob@runoob:~$ docker run -t -i runoob/ubuntu:v2 /bin/bash Docker 容器使用启动容器使用指令docker run -itd ubuntu /bin/bash启动一个容器。 -i: 交互式操作。 -t: 终端。 -d: 后台运行。 ubuntu: ubuntu 镜像。 &#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。 查看容器1$ docker ps -a 启动已停止的容器1$ docker start [容器id | 容器名称] 停止容器1$ docker stop &lt;容器名称 | ID&gt; 进入容器在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入： docker attach docker exec：推荐使用 ，此命令在退出容器终端时不会导致容器停止。 attach 命令 1$ docker attach 1e560fca3906 注意： 如果从这个容器退出，会导致容器的停止。 exec 命令 1$ docker exec -it 243c32535da7 /bin/bash 删除容器删除容器使用 docker rm 命令： 1$ docker rm -f 1e560fca3906 导出和导入容器导出容器 如果要导出本地某个容器，可以使用 docker export 命令。 1$ docker export 1e560fca3906 &gt; ubuntu.tar 导出容器 1e560fca3906 快照到本地文件 ubuntu.tar。 导入容器快照 可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test&#x2F;ubuntu:v1: 1$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1 也可以通过指定 URL 或者某个目录来导入，例如： 1$ docker import http://example.com/exampleimage.tgz example/imagerepo Docker 容器数据卷当容器删除时，容器中的数据也会一并删除，需要将需要的数据持久化到宿主机上（例如：需要将MySQL的数据库文件保存下来） 容器数据卷就是解决这个问题的，它可以将容器内的目录挂载到宿主机上，实现实时同步该目录下的所有文件 【PS : 类似vue的双向绑定，容器目录中的文件改动时宿主机目录中的文件也会变动，同理宿主机改动目录中文件，容器目录中的文件也会变动】 &#x3D;&#x3D;容器的持久化和同步操作！容器间也可以实现数据共享&#x3D;&#x3D; 使用 指令： 1$ docker run -it -v 主机目录:容器内目录 镜像名 /bin/bash 只要容器还存在，绑定的目录就会始终同步，不论容器是否运行中。 匿名挂载和具名挂载 所有的docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/xxxx/_data&quot;（xxxx是卷名）路径下 指定名字进行挂载就是具名挂载，不指定名字会随机生成一个 12345678910111213141516# 匿名挂载docker run -d -p --name nginx01 -v /etc/nginx nginx# 查看所有的volume的情况[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker volume lsDRIVER VOLUME NAMElocal 964b8e505f12f65fb23fd21f05cfa9ecd6c2c6b2ca89c0e44f168bb017dfabd6# 这种就是匿名挂载：我们在-v挂载目录时，只写了容器内的路径，没有写容器外的路径。# 具名挂载[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker run -d -p 3344:80 --name nginx02 -v juming-nginx:/etc/nginx nginx[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker volume lsDRIVER VOLUME NAMElocal 964b8e505f12f65fb23fd21f05cfa9ecd6c2c6b2ca89c0e44f168bb017dfabd6local juming-nginx# 通过 -v 卷名:容器内的路径（具名挂载）# 查看一下这个卷 我们通过具名挂载可以方便的找到我们的一个卷大多数情况在使用的具名挂载 1234$ docker run -it -v xxx 镜像名 /bin/bash-v 容器内的路径 # 匿名挂载-v 卷名:容器内的路径 # 具名挂载-v /宿主机路径:容器内路径 # 指定路径挂载 拓展： 1234567# 通过 -v 容器内的路径:ro rw 改变读写权限ro read only # 只读rw read write # 可读可写# 一旦设置了容器权限，容器对我们挂载出来的内容就有了限定。docker run -d -p 3344:80 --name nginx02 -v juming-nginx:/etc/nginx:ro nginxdocker run -d -p 3344:80 --name nginx02 -v juming-nginx:/etc/nginx:rw nginx# 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！ Docker 容器连接容器中可以运行网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。 网络端口映射指令： 1$ docker run -d -P 镜像名:版本 [命令] 1$ docker run -itd --name 容器名称 -p 主机端口:容器端口 镜像名:版本 [命令] 放在镜像名后的是命令，例： 1$ docker run -itd --name redis-test -p 6379:6379 redis -P :是容器内部端口随机映射到主机的端口。 -p : 是容器内部端口绑定到指定的主机端口。 我们使用 -P 绑定端口号，使用 docker ps 可以看到容器端口 5000 绑定主机端口 32768。 123runoob@runoob:~$ docker psCONTAINER ID IMAGE COMMAND ... PORTS NAMESfce072cc88ce training/webapp &quot;python app.py&quot; ... 0.0.0.0:32768-&gt;5000/tcp grave_hopper 默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 &#x2F;udp。例： 1$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py docker port 命令可以快捷地查看端口的绑定情况。 12user@ubuntu:~$ docker port redis-test 63790.0.0.0:6379 Docker 网络容器互连docker每运行一个容器，就会创建两个虚拟网卡，通过这两个虚拟网卡连接到docker0网卡，docker0网卡扮演了路由的角色，负责转发请求，docker默认通过这种方式进行容器间的互相通信。所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用IP。 –link问题：希望可以使用名字来进行容器访问，达到切换ip服务仍然可用 12345678910111213# 通过服务名ping不通；如何解决？[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker exec -it tomcat02 ping tomcat01ping: tomcat01: Name or service not known# 通过--link可以解决网络连接问题。[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat:7.02393eecb870e5755068ea8b7d8bdcdd0f1ff110534c3359384413677c651bec4[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker exec -it tomcat03 ping tomcat02PING tomcat02 (172.17.0.3) 56(84) bytes of data.64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.085 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.055 ms# 反向可以ping通吗？（不可以）[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker exec -it tomcat02 ping tomcat03ping: tomcat03: Name or service not known 原因：其实就是tomcat03在本地配置了对应关系，访问tomcat02时映射到对应IP 12345678910# 查看[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker exec -it tomcat03 cat /etc/hosts127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.17.0.3 tomcat02 20398a94efa7172.17.0.4 2393eecb870e –link 就是我们在hosts配置中增加了一个”172.17.0.3 tomcat02 20398a94efa7”&#x3D;&#x3D;不建议使用–link&#x3D;&#x3D; 自定义网络所有docker网络 12345user@ubuntu:~$ docker network lsNETWORK ID NAME DRIVER SCOPEc74fcec8d1f2 bridge bridge local62d29c667f8a host host local726864d5969f none null local 网络模式： bridge：桥接 docker（默认，自己创建也使用bridge桥接模式） none：不配置网络 host：和主机共享网络 container：容器网络连通（用的少！局限很大） 创建网络 1234567user@ubuntu:~$ docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynetuser@ubuntu:~$ docker network lsNETWORK ID NAME DRIVER SCOPEc74fcec8d1f2 bridge bridge local62d29c667f8a host host localf55cb2fe8f6f mynet bridge local726864d5969f none null local 使用自己的网络 1user@ubuntu:~$ docker run -d -P --name tomcat-net-01 --net mynet tomcat:7.0 PS: 我们直接启动的命令–net bridge（这个就是我们的docker0）；docker会默认带上这个参数的，以下两种启动方式效果一致。 12docker run -d -P --name tomcat01 tomcatdocker run -d -P --name tomcato1 --het bridge tomcat 我们自定义的网络docker都已经帮我们维护好了对应的关系，可以直接使用名字ping通，推荐这样使用网络！ Docker Dockerfile简介Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。 流程： 创建Dockerfile文件 在文件中编写镜像构建命令 运行命令构建镜像 构建Dockerfile文件和要放入镜像中的文件需要放在同一目录下 使用指令执行构建操作 1$ docker build -t 镜像名:版本 上下文路径 示例 1$ docker build -t nginx:v3 . PS : 上下文路径就是一个路径，docker执行打包会将这个路径下的所有文件发送的docker服务端进行打包（ddocker是C&#x2F;S架构，打包操作是在服务端进行的） 示例1123456789101112131415161718# 构建镜像基于哪个镜像FROM anapsix/alpine-java:8_server-jre_unlimited# 镜像维护者姓名或邮箱地址MAINTAINER test@163.com# 构建镜像时运行的指令RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimeRUN mkdir -p /jero-boot# 这样执行run命令会创建两层镜像，可以使用 &amp;&amp; 连接命令# RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime# &amp;&amp; mkdir -p /jero-boot# 设置工作目录WORKDIR /jero-boot# 声明容器的服务端口EXPOSE 8080# 拷贝文件或目录到容器中ADD ./target/jero-boot-module-system-2.4.6.jar ./# 运行容器时执行的shell环境CMD sleep 60;java -Djava.security.egd=file:/dev/./urandom -jar jero-boot-module-system-2.4.6.jar Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。 示例2Dockerfile 1234567891011121314151617181920FROM centosMAINTAINER xiaoyi&lt;1393687715@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD apache-tomcat-9.0.70.tar.gz /usr/local/ADD jdk-8u351-linux-x64.tar.gz /usr/local/ENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_351ENV CLASS_PATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.70ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.70ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/bin:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.70/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.70/logs/catalina.out build 1docker run -d --name diytomcat01 -p 3355:8080 -v /home/user/Desktop/tomcat/test:/usr/local/apache-tomcat-9.0.70/webapps/test -v /home/user/Desktop/tomcat/tomcatlog:/usr/local/apache-tomcat-9.0.70/logs diytomcat 指令详解COPY复制指令，从上下文目录中复制文件或者目录到容器里指定路径。 格式： 12COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;... &lt;目标路径&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;] **[–chown&#x3D;:]**：可选参数，用户改变复制到容器内文件的拥有者和属组。 **&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如： 12COPY hom* /mydir/COPY hom?.txt /mydir/ **&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。 ADDADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下： ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。 ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。 CMD类似于 RUN 指令，用于运行程序，但二者运行的时间点不同: CMD 在docker run 时运行。 RUN 是在 docker build。 作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。 注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。 格式： 123CMD &lt;shell 命令&gt; CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数 推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。 ENTRYPOINT类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。 但是, 如果运行 docker run 时使用了 –entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。 优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。 注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。 格式： 1ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] 可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。 示例： 假设已通过 Dockerfile 构建了 nginx:test 镜像： 1234FROM nginxENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参 1、不传参运行 1$ docker run nginx:test 容器内会默认运行以下命令，启动主进程。 1$ nginx -c /etc/nginx/nginx.conf 2、传参运行 1$ docker run nginx:test -c /etc/nginx/new.conf 容器内会默认运行以下命令，启动主进程(&#x2F;etc&#x2F;nginx&#x2F;new.conf:假设容器内已有此文件) 1$ nginx -c /etc/nginx/new.conf ENV设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。 格式： 12ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;... 以下示例设置 NODE_VERSION &#x3D; 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用： 1234ENV NODE_VERSION 7.2.0RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; \\ &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot; ARG构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。 构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;&#x3D;&lt;值&gt; 来覆盖。 格式： 1ARG &lt;参数名&gt;[=&lt;默认值&gt;] VOLUME定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。 作用： 避免重要的数据，因容器重启而丢失，这是非常致命的。 避免容器不断变大。 格式： 12VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]VOLUME &lt;路径&gt; 在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。 EXPOSE仅仅只是声明端口。 作用： 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。 在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 格式： 1EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] WORKDIR指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。 docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。 格式： 1WORKDIR &lt;工作目录路径&gt; USER用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。 格式： 1USER &lt;用户名&gt;[:&lt;用户组&gt;] HEALTHCHECK用于指定某个程序或者指令来监控 docker 容器服务的运行状态。 格式： 123HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令HEALTHCHECK [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。 ONBUILD用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。 格式： 1ONBUILD &lt;其它指令&gt; LABELLABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下： 1LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ... 比如我们可以添加镜像的作者： 1LABEL org.opencontainers.image.authors=&quot;author&quot; Dockerfile指令简洁版 FROM 构建镜像基于哪个镜像 MAINTAINER 镜像维护者姓名或邮箱地址 RUN 构建镜像时运行的指令 CMD 运行容器时执行的shell环境 VOLUME 指定容器挂载点到宿主机自动生成的目录或其他容器 USER 为RUN、CMD、和 ENTRYPOINT 执行命令指定运行用户 WORKDIR 为 RUN、CMD、ENTRYPOINT、COPY 和 ADD 设置工作目录，就是切换目录 HEALTHCHECH 健康检查 ARG 构建时指定的一些参数 EXPOSE 声明容器的服务端口（仅仅是声明） ENV 设置容器环境变量 ADD 拷贝文件或目录到容器中，如果是URL或压缩包便会自动下载或自动解压 COPY 拷贝文件或目录到容器中，跟ADD类似，但不具备自动下载或解压的功能 ENTRYPOINT 运行容器时执行的shell命令 Docker Compose简介Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，可以使用 YML 文件来配置应用程序需要的所有服务。然后使用命令就可以从 YML 文件配置中创建并启动所有服务。 &#x2F;&#x2F; 暂时用不到","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"服务器","slug":"后端/服务器","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}],"author":["extends"]},{"title":"WebSocket前后端搭建","slug":"WebSocket前后端搭建","date":"2022-12-09T08:09:11.000Z","updated":"2023-01-03T09:31:58.000Z","comments":true,"path":"2022/12/09/WebSocket前后端搭建/","link":"","permalink":"http://example.com/2022/12/09/WebSocket%E5%89%8D%E5%90%8E%E7%AB%AF%E6%90%AD%E5%BB%BA/","excerpt":"","text":"简介WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 特点： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 对比传统实现服务器推送技术 ajax轮询 客户端每隔一段时间就发送一次请求，询问服务器是否有新消息 long poll long poll 原理和 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型。当客户端发起请求，服务端收到后如果没有新消息要发送给客户端的话就会等待，一直等待到有新消息再返回，如果时间超时，客户端收到超时的消息后会重新再发送一个请求。 实现流程 搭建后端服务器，初始化项目 创建配置类，注入ServerEndpointExporter对象 1234567@Configurationpublic class webSocketConfig &#123; @Bean public ServerEndpointExporter serverEndpointExporter()&#123; return new ServerEndpointExporter(); &#125;&#125; 创建WebSocketServer类，编写websocket服务。 12345678910111213141516171819202122232425@ServerEndpoint(&quot;/msgChannel/&#123;id&#125;&quot;)@Componentpublic class WebSocketServer &#123; @OnOpen public void open(@PathParam(&quot;id&quot;)String id, Session session)&#123; System.out.println(&quot;与[&quot;+id+&quot;]建立连接&quot;); &#125; @OnClose public void close() &#123; // 添加关闭会话时的操作 System.out.println(&quot;断开连接&quot;); &#125; @OnError public void error(Throwable t) &#123; // 添加处理错误的操作 t.printStackTrace(); &#125; @OnMessage public void getMessage(String message) &#123; System.out.println(&quot;收到消息:&quot; + message); &#125;&#125; web页面直接创建webSocket对象。 12345678// 创建连接let socket = new WebSocket(&#x27;ws://localhost:9863/msgChannel&#x27;)// 发送消息socket.send(msg)// 监听消息socket.onmessage = (event) =&gt; &#123; console.log(&#x27;Message from server &#x27;, event.data);&#125;; 客户端【Web】1234// 创建连接let socket = new WebSocket(&#x27;ws://localhost:9863/msgChannel&#x27;)// 发送消息socket.send(msg) 重点API构造方法1let aWebSocket = new WebSocket(url [, protocols]); 参数 url 要连接的 URL；这应该是 WebSocket 服务器响应的 URL。 protocols 可选 一个协议字符串或者一个包含协议字符串的数组。这些字符串用于指定子协议，这样单个服务器可以实现多个 WebSocket 子协议（例如，您可能希望一台服务器能够根据指定的协议（protocol）处理不同类型的交互）。如果不指定协议字符串，则假定为空字符串。 实例方法 close()参数 code 可选 一个数字状态码，它解释了连接关闭的原因。如果没有传这个参数，默认使用 1005。CloseEvent的允许的状态码见状态码列表 。 reason 可选 一个人类可读的字符串，它解释了连接关闭的原因。这个 UTF-8 编码的字符串不能超过 123 个字节。 实例方法 send()参数 data 用于传输至服务器的数据。 data必须是以下类型之一： USVString文本字符串【常用】 ArrayBuffer有类型的数组对象 Blob二进制blob数据【常用】 事件 closeWebSocket.onclose 属性返回一个事件监听器，这个事件监听器将在 WebSocket 连接的readyState变为 CLOSED时被调用，它接收一个名字为“close”的 CloseEvent事件。 123WebSocket.onclose = function(event) &#123; console.log(&quot;WebSocket已关闭&quot;);&#125;; 事件 error当websocket的连接由于一些错误事件的发生 (例如无法发送一些数据) 而被关闭时，一个error事件将被触发。 1234const socket = new WebSocket(&#x27;ws://localhost:8080&#x27;);socket.addEventListener(&#x27;error&#x27;, function (event) &#123; console.log(&#x27;WebSocket error: &#x27;, event);&#125;); 事件 messagemessage 事件会在 WebSocket 接收到新消息时被触发。 123456// 创建一个 WebSocket 连接const socket = new WebSocket(&#x27;ws://localhost:8080&#x27;);// 监听消息socket.onmessage = (event) =&gt; &#123; console.log(&#x27;Message from server &#x27;, event.data);&#125;; 事件 open**WebSocket.onopen**属性定义一个事件处理程序，当WebSocket的连接状态readyState变为1时调用;这意味着当前连接已经准备好发送和接受数据。 12345const socket = new WebSocket(&#x27;ws://localhost:8080&#x27;);// 也就是说当服务端也同意建立连接后，该事件就会触发socket.onopen = function(event) &#123; console.log(&quot;WebSocket is open now.&quot;);&#125;; 服务端【java】javax提供了websocket的功能实现。可以直接使用注解的方式进行开发。 重点注解 @OnOpen有连接时的触发函数。 我们可以在用户连接时记录用户的连接带的参数，只需在参数列表中增加参数：@PathParam(“paraName”) String paraName。 @OnMessage收到消息时调用的函数，其中Session是每个websocket特有的数据成员 @OnClose连接关闭时的调用方法。 @OnError发生意外错误时调用的函数。 @ServerEndpoint进行声明接口：@ServerEndpoint(value&#x3D;”&#x2F;websocket&#x2F;{paraName}”) 重点对象和方法Session每个Session代表了两个websocket断点的会话；当websocket握手成功后，websocket就会提供一个打开的Session，可以通过这个Session来对另一个端点发送数据；如果Session关闭后发送数据将会报错。 Session.getBasicRemote().sendText(“message”)向该Session连接的用户发送字符串数据。 Session.getAsyncRemote().sendText(“message”)异步非阻塞向该Session连接的用户发送字符串数据。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import com.xiaoyi.websocketchat.handler.WebSocketMassageHandler;import com.xiaoyi.websocketchat.handlerMapping.MessageHandlerMapping;import org.springframework.stereotype.Component;import javax.websocket.*;import javax.websocket.server.PathParam;import javax.websocket.server.ServerEndpoint;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * @author 小易 * @version 1.0 * @description TODO webSocket服务 * @date 2022/12/9 9:07 */@ServerEndpoint(&quot;/msgChannel/&#123;id&#125;&quot;)@Componentpublic class WebSocketServer &#123; /** 会话集合 */ private static final Map&lt;String, WebSocketServer&gt; sessionMap = new ConcurrentHashMap&lt;&gt;(); /** 与某个客户端的连接会话，需要通过它来给客户端发送数据 */ private Session session; /** 接收id */ private String id = &quot;&quot;; @OnOpen public void open(@PathParam(&quot;id&quot;)String id, Session session)&#123; this.session = session; this.id = id; sessionMap.put(id, this); System.out.println(&quot;与[&quot;+id+&quot;]建立连接&quot;); &#125; @OnClose public void close() &#123; // 添加关闭会话时的操作 sessionMap.remove(this.id); System.out.println(&quot;与[&quot;+id+&quot;]断开连接&quot;); &#125; @OnError public void error(Throwable t) &#123; // 添加处理错误的操作 System.out.println(&quot;发生错误&quot;); t.printStackTrace(); &#125; @OnMessage public void getMessage(String message) &#123; // 接收到消息后通过处理器适配器获取对应的消息处理器 WebSocketMassageHandler handler = MessageHandlerMapping.getWebSocketMessageHandler(message); // 使用消息处理器处理消息 handler.handler(message, this); &#125; public synchronized void sendMessage(String message) &#123; this.session.getAsyncRemote().sendText(message);//非阻塞式的 &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"WebSocket","slug":"前端/WebSocket","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/WebSocket/"}],"tags":[{"name":"websocket","slug":"websocket","permalink":"http://example.com/tags/websocket/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"}],"author":["extends"]},{"title":"Axios跨域","slug":"Axios跨域","date":"2022-11-17T07:35:59.000Z","updated":"2023-01-03T09:31:42.000Z","comments":true,"path":"2022/11/17/Axios跨域/","link":"","permalink":"http://example.com/2022/11/17/Axios%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"1报错信息: Access to XMLHttpRequest at &#x27;http://localhost:8888/cert/certCompany/list2&#x27; from origin &#x27;http://localhost:8889&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. 解决方案 main.js 引入axios 1234//引入axios by zhengkai.blog.csdn.netimport axios from &#x27;axios&#x27;Vue.prototype.$axios = axiosaxios.defaults.baseURL = &#x27;/api&#x27; //自动附加在所有axios请求前面，则可以省略/api，直接写&#x27;/xxxx/xxx&#x27;。否则需要设置&#x27;/api/xxxx/xxx&#x27; config.index.js 改造proxyTable部分，引入虚拟代理 ，请求target这个地址的时候直接写成/api即可。 1234567891011121314151617181920212223dev: &#123; env: require(&#x27;./dev.env&#x27;), port: 8889, autoOpenBrowser: true, assetsSubDirectory: &#x27;static&#x27;, assetsPublicPath: &#x27;/&#x27;, proxyTable: &#123; //axios跨域改造 by zhengkai.blog.csdn.net &#x27;/api&#x27;: &#123; target:&#x27;http://localhost:8888/cert/&#x27;, // 你请求的第三方接口 changeOrigin:true, // 在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题 pathRewrite:&#123; // 路径重写， &#x27;^/api&#x27;: &#x27;&#x27; // 替换target中的请求地址，也就是说/api=/target，请求target这个地址的时候直接写成/api即可。 &#125; &#125; &#125;, // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot; // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. cssSourceMap: false &#125; 业务.vue 1234567axios.post(&#x27;/certCompany/list2&#x27;,JSON.stringify(this.searchParam)) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"前端/axios","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/axios/"}],"tags":[{"name":"axios","slug":"axios","permalink":"http://example.com/tags/axios/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}],"author":["extends"]},{"title":"vue中画面样式闪烁","slug":"vue中画面样式闪烁","date":"2022-11-17T07:32:07.000Z","updated":"2023-01-03T09:31:50.000Z","comments":true,"path":"2022/11/17/vue中画面样式闪烁/","link":"","permalink":"http://example.com/2022/11/17/vue%E4%B8%AD%E7%94%BB%E9%9D%A2%E6%A0%B7%E5%BC%8F%E9%97%AA%E7%83%81/","excerpt":"","text":"小型项目中使用 v-cloak 指令是解决屏幕闪动，在大型、工程化的项目中（webpack、vue-router）只有一个空的 div 元素，元素中的内容是通过路由挂载来实现的，这时我们就不需要用到 v-cloak 指令了。 v-cloak: ​ 可以使用 v-cloak 指令设置样式，这些样式会在 Vue 实例编译结束时，从绑定的 HTML 元素上被移除。 123&lt;div id=&quot;app&quot; v-cloak&gt; &#123;&#123;context&#125;&#125;&lt;/div&gt; 123[v-cloak]&#123; display: none;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"屏幕闪动","slug":"屏幕闪动","permalink":"http://example.com/tags/%E5%B1%8F%E5%B9%95%E9%97%AA%E5%8A%A8/"}],"author":["extends"]}],"categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"前后端","slug":"前后端","permalink":"http://example.com/categories/%E5%89%8D%E5%90%8E%E7%AB%AF/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"前端/axios","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/axios/"},{"name":"服务器","slug":"后端/服务器","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"WebSocket","slug":"前端/WebSocket","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/WebSocket/"},{"name":"vue","slug":"前端/vue","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"springboot","slug":"springboot","permalink":"http://example.com/tags/springboot/"},{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"},{"name":"计算机原理","slug":"计算机原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"maven","slug":"maven","permalink":"http://example.com/tags/maven/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"mybatis","slug":"mybatis","permalink":"http://example.com/tags/mybatis/"},{"name":"swagger","slug":"swagger","permalink":"http://example.com/tags/swagger/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","permalink":"http://example.com/tags/%E5%90%8E%E7%AB%AF/"},{"name":"axios","slug":"axios","permalink":"http://example.com/tags/axios/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"websocket","slug":"websocket","permalink":"http://example.com/tags/websocket/"},{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"},{"name":"屏幕闪动","slug":"屏幕闪动","permalink":"http://example.com/tags/%E5%B1%8F%E5%B9%95%E9%97%AA%E5%8A%A8/"}]}